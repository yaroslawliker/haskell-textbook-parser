Частина ІІ. Мова Haskell 2.1 Типи в Haskell Мова програмування Haskell      Мова програмування Haskell названа на честь американського математика Гаскелла Каррі (Haskell Curry), роботи якого в галузі математичної логіки є базовими для функціонального програмування. Haskell є строго типізованою винятково функціональною мовою, в основі якої безпосередньо лежить лямбда-числення.       Однак система типів мови Haskell відрізняється від систем типів більшості мов, в певній мірі вона є багатшою.  Типи та значення      Оскільки Haskell є чисто функціональною мовою, всі обчислення здійснюються за допомогою обчислення виразів (синтаксичних термів), що повертають значення (абстрактні сутності, які розглядаються як відповіді). Основні типи в мові Haskell: • Char – символьний тип, • Bool – True або False, • Int – цілочисельний тип; його розмір може бути 32 або 64 біти залежно від архітектури, • Integer – «нескінченне» ціле, • Double – дробове число (з плаваючою крапкою).      Кожне значення має з пов’язаний з ним тип. На інтуїтивному рівні можна розглядати типи як множини значень.      Приклади виразів включають як атомарні значення (атоми), такі як ціле число 5, символ 'a' і функція  \x -> x+1, так і структуровані значення, такі як список [1, 2, 3] або пара ('b', 4).      Так само як вирази позначають значення, вирази типу є синтаксичними термами, які позначають значення типу (або просто типи). Прикладами виразів типу можуть бути атомарні типи Int (цілі необмеженого діапазону), Char (символи), Int->Int (функції, що відображають Int в Int), а також структуровані типи [Int] (однорідний список цілих) та (Char, Int) (пара із символу та цілого).      Всі значення в Haskell є сутністю «першого класу»: вони можуть передаватися в функції як аргументи, повертатися з них як результати, розміщуватися в структурах даних тощо.      З іншого боку, типи у Haskell – не «першокласні» сутності. Насправді, типи описують значення; зв'язування деякого значення з його типом називається типізацією. Розглянемо приклади: 5 :: Int  'a' :: Char  inc :: Int -> Int  [1,2,3] :: [Int]  ('b',4) :: (Char,Int)       Функції Haskell зазвичай визначаються як набір рівнянь. Наприклад, функція inc може бути визначена одним рівнянням: inc n = n + 1      Статична система типів мови Haskell визначає формальний зв'язок між типами та значеннями. Статична система типів гарантує, що програми на Haskell «типобезпечні», тобто програміст не допустив будь-якої плутанини в типах. Наприклад, не можна скласти два символи, тому вираз 'a' + 'b' є неправильно типізованим.      Основна перевага статично типізованих мов загальновідома: всі помилки типізації виявляються під час компіляції. Однак система типів не перехоплює помилки в повному обсязі: вираз 1/0 є вірним за типом, але його обчислення призведе до помилки під час виконання.   	 Поліморфні типи      До складу Haskell включено також поліморфні типи – типи, які певним чином містять квантор загальності над усіма типами.      Вирази з поліморфними типами за своєю сутністю описують сімейства типів. Наприклад, (forall a) [a] – це сімейство типів, що складається з типів списку з елементами із a, для будь-якого типу a.      Список цілих (наприклад, [1, 2, 3]), список символів (['a', 'b', 'c']), список цілих списків тощо будуть членами цього сімейства, тоді як [2,'b'] туди не належатиме, оскільки не існує одного типу, який включав би і 2, і 'b'.      Список [1, 2, 3] у Haskell насправді є скороченою формою запису для списку 1:(2:(3:[ ])), де [ ] – це порожній список, а «:» – інфіксний оператор, який додає свій перший аргумент на початок свого другого аргументу (деякого списку). (Зауважимо, що оператори «:» та «[ ]» відповідають cons і nil у мові Lisp.) Оскільки оператор «:» правоасоціативний, можна також записати цей список як 1:2:3:[ ].      Розглянемо приклад функції яка підраховує кількість елементів у списку: length :: [a] -> Int  length [] = 0  length (x:xs) = 1 + length xs      Цей приклад підкреслює важливий аспект мови Haskell: зіставлення зі зразком (pattern matching). Ліві частини рівнянь містять зразки, такі як [ ] і x: xs.      При застосуванні функції ці зразки зіставляються з фактичними параметрами інтуїтивно зрозумілим способом ([ ] відповідає тільки порожньому списку, а x: xs буде успішно зіставлений з будь-яким списком, що містить хоча б один елемент, при цьому x зв'язується з першим елементом, а xs – з рештою списку).      Якщо співставлення пройшло успішно, права частина рівності обчислюється і повертається як результат застосування функції. Якщо зіставлення не вдале, пробується наступне рівняння, а якщо всі рівняння призведуть до невдалого співставлення, то результатом буде помилка.      Функція length також є прикладом поліморфної функції. Вона може бути застосована до списку, що містить елементи довільного типу, наприклад length [1,2,3] => 3  length ['a','b','c'] => 3  length [[1],[2],[3]] => 3        Для роботи зі списками в Haskell існують вбудовані функції. Наприклад, функція head повертає перший елемент списку, а функція tail повертає все, крім першого елемента.      Можна помітити, що деякі типи, строго кажучи, є більш загальними за інші, у тому сенсі, що множина заданих ними значень ширша.      Наприклад, тип [a] є більш загальним, ніж [Char]. Іншими словами, останній може бути виведений з першого за допомогою відповідної підстановки для a.      Відносно подібного порядку узагальнення, система типів Haskell має дві важливі властивості:  • для будь-якого правильно типізованого виразу гарантується існування єдиного основного типу,  • основний тип може бути виведений автоматично.      Основний тип виразу або функції – це найзагальніший тип, який «містить всі екземпляри виразу». Наприклад, основний тип функції head – це [a] -> a; тип a є вірним, але надлишково загальним, у той час як типи на кшталт [Int] -> Int занадто часткові.      Існування та єдиність основного типу є відмінною ознакою системи типів Хіндлі-Мілнера, яка лежить в основі системи типів Haskell.  Типи, що визначаються користувачем Можна визначати власні типи в Haskell за допомогою оголошення data. Розглянемо приклади. data Nat = Zero | Succ Nat      Маємо один конструктор-примітив Zero і один конструктор Succ, за допомогою якого можна створювати складені значення.      Визначивши тип Nat таким чином, ми говоримо, що значення типу Nat можуть бути тільки такими: Zero, Succ Zero, Succ (Succ Zero),  Succ (Succ (Succ Zero)), ... Тобто всі значення є ланцюжками Succ із Zero на кінці.      Якщо спробувати десь побудувати значення, яке не відповідає визначеному вище типу, буде помилка компіляції, тобто програма не пройде перевірку типів.      Таким чином типи описують множину допустимих значень. Так, наступні значення неприпустимі для Nat: Succ Zero Zero, Succ Succ, True, Zero (Zero Succ), ...  Структура типів алгебри даних      Для конструювання нових типів існує лише дві операції: сума та добуток. Розглянемо для початку два крайні випадки. Тільки добуток типів: data T = Name T1 T2 ... TN      Тут значення нового типу T складається із значень типів T1, T2, …, TN, й існує лише один спосіб скласти значення цього типу.      Єдине, що можна зробити, це застосувати до значень типів Ti конструктор Name. Приклад: data Time = Time Hour Second Minute Тільки сума типів: Data T = Name1 | Name2 | ... | NameN      Тут у нового типу T може лише декілька значень, і вони перераховуються в альтернативах через знак «|». Приклад: data Bool = True | False За такою ж схемою можна визначити наступний колірний тип: data Color = Red | Green | Blue | Indigo | Violet І Bool, і Color складаються зі скінченного числа конструкторів даних. Розглянемо приклад: data Color = Red | Green deriving (Eq) ffunc :: Color -> Int ffunc (x) = if x == Red then 1 else 2      Слід зазначити: кожен добуток типів визначає новий конструктор. Кількість конструкторів у типі дорівнює числу альтернатив. Так, у першому випадку була одна альтернатива, і отже, був лише один конструктор Name.      Імена конструкторів мають бути унікальними в межах модуля. Це говорить про те, що за іменем конструктора компілятор «знає», значення якого типу він може побудувати.      Добуток типів складається з конструктора, за яким через проміжок йдуть підтипи. Така структура невипадкова, вона копіює структуру функції. В якості імені функції виступає конструктор, а в якості аргументу – значення заданих у добутку підтипів. Функція-конструктор після застосування «обгортає» значення аргументів і створює нове значення.      За рахунок цього можна визначати типи по-іншому: визначити їх у стилі класів типів: data Bool where      True :: Bool      False :: Bool Тут «класом» є Bool, у якого два методи. У такому ж стилі можна визначити Nat: data Nat where     Zero :: Nat     Succ :: Nat -> Nat Аналогічно можна визначати і списки: data [a] where     [] :: [a]     (:) :: a -> [a] -> [a]      Конструктор порожнього списку «[ ]» є константою, а конструктор об'єднання елемента зі списком «(:)» є функцією.      Однак варто зауважити, що [ ] у цьому сенсі також є конструктором типу. Для будь-якого типу t ми можемо «застосувати» [ ], щоб створити новий тип [t].      Синтаксис мови Haskell дозволяє записати [ ] t як [t]. Аналогічно, -> теж є конструктором типу: для будь-яких двох типів t і u, t -> u є типом функції, що відображає елементи типу t у елементи типу u. Наступний приклад вводить тип, у якого лише один конструктор даних: data Point a = Pt a a (Тут тип бінарного конструктора даних Pt визначений як a -> a -> Point a).      Через єдиність конструктора такі типи, як Point, часто називають типами кортежів (tuple), оскільки вони по суті представляють декартів добуток (в нашому випадку бінарний) інших типів (кортежі певним чином відповідають поняттю запису (record) в інших мовах).      Слід зауважити, що Point – це приклад поліморфного типу: для будьякого типу t він визначає тип декартової точки, яка використовує t як тип координат. З цих міркувань зрозуміло, що тип Point є унарним конструктором типу, оскільки для даного типу t він конструює новий тип Point t.      Важливо розрізняти застосування конструктора даних, що повертає значення, і застосування конструктора типу, що повертає тип: перше відбувається під час виконання і є способом, яким здійснюються обчислення в Haskell, тоді як останнє відбувається під час компіляції і є частиною процесу, в ході якого система типів забезпечує «типобезпеку».  Рекурсивні типи Типи можуть бути рекурсивними, як у випадку типу двійкових дерев: data Tree a = Leaf a | Branch (Tree a) (Tree a) Тут визначається поліморфний тип бінарного дерева, елементами якого є або вузли-листи, що містять значення типу a, або внутрішні вузли («гілки»), що містять (рекурсивно) два піддерева.      При читанні оголошень data, подібних цьому, слід пам'ятати, що Tree –  це конструктор типу, тоді як Branch і Leaf – конструктори даних.      Крім встановлення зв'язку між цими конструкторами, це оголошення по суті є визначенням типів для Branch та Leaf: Branch :: Tree a -> Tree a -> Tree a Leaf :: a -> Tree a      Розглянемо рекурсивну функцію, пов'язану із типом Tree. Припустимо, необхідно визначити функцію fringe, яка повертає список усіх елементів у листі дерева зліва направо. Зазвичай буває корисно спочатку записати тип нової функції: наразі видно, що її тип може бути Tree a -> [a].      Таким чином, fringe – поліморфна функція, що відображає дерево елементів типу a у список елементів типу a. Відповідне визначення має вигляд: fringe :: Tree a -> [a] fringe (Leaf x) = [x]       fringe (Branch left right) = fringe left ++ fringe right Тут «++» є інфіксним оператором, що конкатенує два списки. Розглянемо інший приклад. data Nat = Zero | Succ Nat У другій альтернативі бере участь сам тип Nat.      Як побачили у попередньому прикладі, рекурсивні визначення типів призводять до рекурсивних функцій. (+) a Zero = a (+) a (Succ b) = Succ (a + b) (*) a Zero = Zero (*) a (Succ b) = a + (a * b) Списки як рекурсивний тип: data [a] = [] | a : [a] deriving (Eq, Ord) Функції списків також будуть рекурсивними. Розглянемо три основні функції роботи зі списками. 1. Функція map: map :: (a -> b) -> [a] -> [b] map f[] = [] map f (a:as) = f a : map f as Ця функція застосовує функцію f для кожного елемента списку. 2. Функція filter: filter :: (a -> Bool) -> [a] -> [a] filter p[] = [] filter p (x:xs) = if p x then x : filter p xs else filter p xs      Функція застосовує предикат p до кожного елемента списку та повертає новий список, що складається з елементів, для яких предикат true. Тому після введення Prelude >filter isUpper "Hello World" на екрані: "HW". 3. Функція згортки foldr: foldr :: (a -> b -> b) -> b -> [a] -> b foldr f z [] = z foldr f z (a:as) = f a (foldr f z as) Введемо: Prelude> let xs = [1,2,3,4,5] Prelude> foldr (+) 0 xs На екрані: 15.  Синоніми типів      З міркувань зручності в Haskell забезпечується можливість визначати синоніми типів, тобто імена для типів, що часто використовуються. Синоніми типів створюються за допомогою оголошення type. Приклад: type String = [Char] type Person = (Name,Address) type Name = String data Address = None | String      Синоніми типів не визначають нових типів, а просто задають нові імена існуючим. Наприклад, тип Person -> Name точно відповідає типу (String, Address) -> String. Можна давати нові імена поліморфним типам: type AssocList a b = [(a, b)] Це тип асоціативного списку, який асоціює значення типу a зі значеннями типу b.  Вбудовані типи      Вбудовані типи не відрізняються від користувацьких, за винятком спеціального синтаксису. 1) Булевий тип data  Bool  = False | True    deriving (Read, Show, Eq, Ord, Enum, Bounded) Булевий тип Bool є переліком.       Основні булеві функції – це «&&» (і), «||» (або) та not (заперечення). Ім'я otherwise (інакше) визначено як True. 2) Символи та рядки      Символьний тип Char є переліченням, значенням якого є символи Unicode. Тип Char є екземпляром класів Read, Show, Eq, Ord, Enum та Bounded.      Функції toEnum і fromEnum, які є стандартними функціями класу Enum, відповідно відображають символи в тип Int і навпаки.      Наступні літерали рівнозначні: \a і \BEL, \b і \BS, \f і \FF, \r і \CR, \t і \HT, \v і \VT \n і \LF. Рядок – це список символів:  type String = [Char] Рядки можна скоротити, використовуючи лексичний синтаксис.  	Наприклад, 	"A string" 	є 	скороченням 	(абревіатурою) 	для [ 'A', ' ', 's', 't', 'r', 'i', 'n', 'g']. 3) Кортежі Кортежі – це алгебраїчний тип даних зі спеціальним синтаксисом. Тип кожного кортежу має один конструктор.      Всі кортежі є екземплярами класів Eq, Ord, Bounded, Read, та Show (за умови, що всі їх складові типи є екземплярами цих класів).      Конструктор для кортежу має вигляд: (x, y) або (,) x y. Обидва записи позначають той самий кортеж. Аналогічно для конструкторів типів кортежів: той самий тип будуть позначати (Int, Bool, Int) та (,,) Int Bool Int. 4) Одиничний тип даних data  () = () deriving (Eq, Ord, Bounded, Enum, Read,  Show)      Одиничний тип даних ( ) має єдиний, відмінний від _|_, член – конструктор без аргументів ( ). 5) Типи функцій Функції – це абстрактний тип. 6) Типи IO та IOError Тип IO вказує на операції, які взаємодіють із зовнішнім світом.      Тип IO є абстрактним: жодних конструкторів не видно для користувача. IO є екземпляром класів Monad та Functor.      Тип IOError є абстрактним типом, який представляє помилки, спричинені операціями введення-виведення. Він є екземпляром класів Show та Eq. Значення цього типу створюються різними функціями введення- виведення. 7) Числа      Haskell пропонує кілька видів чисел; на числові типи та операції над ними сильно вплинули Common Lisp та Scheme. Integer – цілі числа довільної точності, Int – цілі числа фіксованої точності, (Integral a) => Ratio a – раціональні числа, Float – дійсні числа з плаваючою крапкою одинарної точності, Double – дійсні числа з плаваючою крапкою подвійної точності, (RealFloat a) => Complex a – комплексні числа з плаваючою крапкою.  2.2 Функції Арифметичні та теоретико-числові операції      Інфіксні методи класу (+), (*), (–) та унарна функція negate (яка також може бути записана як знак мінус, що стоїть перед аргументом), можуть бути застосовані до всіх чисел.      Методи quot, rem задовольняють наступним умовам, якщо y відмінний від нуля:                     (x `quot` y) * y + (x `rem` y) = = x (тут `quot` – ділення націло із округленням у бік нуля).      Метод класу quotRem приймає в якості аргументів ділене та дільник і повертає пару (частка, остача):               quotRem x y  =  (x `quot` y, x `rem` y) Також для цілих чисел визначені предикати even (парний) і odd (непарний):  even x = x `rem` = 2 == 0 odd = not. even  Піднесення до степеня та логарифми      Показникова функція exp і логарифмічна функція log приймають як аргумент число з плаваючою крапкою і використовують при обчисленні основу e. logBase a x повертає логарифм x за основою a. sqrt повертає арифметичне значення квадратного кореня числа з плаваючою крапкою.      Є три операції піднесення до степеня, кожна з яких приймає по два аргументи:  • (^) підносить будь-яке число до невід'ємного цілого степеня,  • (^^) підносить дробове число до будь-якого цілого степеня,  • (**) приймає два аргументи з плаваючою крапкою.      Значення x^0 або x^^0 дорівнює 1 для будь-якого x, включаючи нуль; значення 0**y не визначено.    Абсолютна величина та знак      Функції abs і signum можуть бути застосовані до будь-якого числа і задовольняють умові:  abs x * signum x = = x.  Функції у Haskell      Оскільки Haskell є функціональною мовою, то функції відіграють у ньому головну роль. Розглянемо визначення функції, яка додає два своїх аргументи: add :: Int -> Int -> Int add x y = x + y e1 :: Int e1 = add 1 2 На екрані 3.      Це приклад каррованої функції. (Термін «каррований» походить від прізвища Хаскелла Каррі, який популяризував цю ідею).      Щоб досягти ефекту некаррованої функції, необхідно використовувати кортеж: add (x, y) = x + y Однак у цьому випадку add насправді є функцією від одного аргументу. Застосування першого варіанта функції add має вигляд add e1 e2 та еквівалентно ((add e1) e2), оскільки застосування функції лівоасоціативне.      Іншими словами, застосування add до першого аргументу породжує нову функцію, яка потім застосовується до другого аргументу. Це називається каррінгом. Це відповідає типу функції add, Int -> Int -> Int.  Використовуючи add, можна визначити inc наступним способом: inc :: Int -> Int inc = add 1      Розглянемо випадок, що ілюструє користь передачі функції як аргумента: add :: Int -> Int -> Int add x y = x+y map1 :: (a->b) -> [a] -> [b] map1 f [] = [] map1 f (x: xs) = f x : map1 f xs Виклик матиме вигляд map1 (add 1) [1,2,3] На екрані [2, 3, 4].  Символ долара      Складні вирази вигляду a + b зустрічаються досить часто, тому дужки можна замінити символом долара, щоб їх уникати: f $ a + b еквівалентно f (a + b) і транслюється у f(a + b). Зокрема, знак долара можна вкладати:  f $ g x $ h y $ a + b – еквівалентно  f (g x (h y (a + b))) і транслюється як f(g(x, h(y, a + b))).      Іноді можна побачити варіант з кутовими дужками: <$>. Можна вважати це тим самим, що і $. Також зустрічається <*> – вважається, що це кома, і f <$> a <*> b транслюється у f(a, b).   	 Зворотні апострофи      x `f` y транслюється у f(x, y). Те, що знаходиться між апострофами, –  функція, зазвичай бінарна, а праворуч і ліворуч – аргументи.  Лямбда-абстракції      Замість використання рівнянь, функції можна визначати «анонімно», через лямбда-абстракцію. Наприклад, функція, еквівалентна inc, може бути записана як \x -> x + 1. Аналогічно, функція add еквівалентна \x -> \y -> x + y (або \x y -> x + y). Тоді функцію map можна викликати: map1 (x->x+1) [1,2,3]  Інфіксні оператори      Інфіксні оператори є звичайними функціями і можуть бути визначені у вигляді рівнянь. Розглянемо приклад визначення оператора конкатенації списків: (++) :: [a] -> [a] -> [a] [] ++ ys = ys (x:xs) ++ ys = x : (xs++ys)      Лексично інфіксні оператори мають повністю складатися зі знаків (тобто не букв, цифр чи прогалин), на противагу звичайним ідентифікаторам, які є буквено-цифровими. Haskell не має префіксних операторів, окрім мінуса (–), який є й інфіксним, і префіксним.      В якості іншого прикладу розглянемо інфіксний оператор, що оперує функціями та здійснює композицію функцій: ( . ) :: (b->c) -> (a->b) -> (a->c) f. g = \ x -> f (g x) Використання цього оператора матиме вигляд (inc. inc) 2  Розтини      Оскільки інфіксні оператори насправді – просто функції, їм має сенс також надати можливість часткового застосування. У Haskell часткове застосування інфіксного оператора називають розтином. Розглянемо приклад: (x+) = \y -> x+y (+y) = \x -> x+y (+) = \x y -> x+y Використання таких операторів має вигляд add1 :: Int -> Int add1 = (+ 1) e3 = add1 4 Тепер функції add та inc можна визначити так: inc = (+1) add = (+)      Можна змусити інфіксний оператор виступати як функціональне значення, для цього необхідно записати ідентифікатор в одиночні лапки. Наприклад, x `add` y – це те саме, що і add x y.  Оголошення пріоритетів операторів        Пріоритети операторів можуть бути задані для будь-якого інфіксного оператора чи конструктора. Ці оголошення вказують рівень пріоритету від 0 до 9 (пріоритет 9 – найвищий; звичайне застосування функції трактується як рівень пріоритету, що дорівнює 10). Наприклад, оголошення пріоритетів операторів для «++» та «.» такі: infixr 5 ++ infixr 9 .      Обидва вони оголошені як правоасоціативні, перший – із рівнем пріоритету 5, другий – 9. Лівоасоціативність задається за допомогою infixl, відсутність асоціативності – за допомогою infix.      У тому самому оголошенні може бути заданий пріоритет кількох операторів.      Якщо для даного оператора немає оголошення пріоритету, за замовчуванням приймається infixl 9.  Строгі та нестрогі функції      Функція називається строгою, якщо її застосування до обчислення, що незавершується, веде до того, що вона теж ніколи не завершиться.      У більшості мов програмування всі функції є строгими. Однак у Haskell це не так. Розглянемо приклад. Розглянемо функцію const1 :: a -> Int const1 x = 1 Нехай також є функція bot: bot = bot Тоді у Haskell виклик const1 bot поверне 1.      Оскільки помилки та обчислення, що не завершуються, є семантично еквівалентними в Haskell, наведене справджується також і для помилок: наприклад, const1 (1 / 0) також повертає 1.      Головною перевагою нестрогих функцій є те, що вони звільняють програміста від багатьох турбот про порядок обчислень. Значення, що вимагають істотних обчислювальних витрат, можуть передаватися як аргументи функції без остраху того, що вони можуть бути обчислені без необхідності.      Важливим прикладом цього є можливість роботи з нескінченними структурами даних.   	 2.3 Нескінченні структури даних, ліниві зразки та вкладені форми «Нескінченні» структури даних      Структури даних у Haskell також є нестрогими. Іншими словами, нестрогими є конструктори даних.      Нестрогі конструктори допускають створення нескінченних (концептуально) структур даних. Наприклад, нескінченний список одиниць: ones = 1 : ones Інший приклад, функція numsFrom: numsFrom n = n : numsFrom (n+1) Тобто, numsFrom n – це нескінченний список послідовних цілих чисел, починаючи з n. З її допомогою ми можемо отримати нескінченний список квадратів: squares = map (^2) (numsFrom 0)      Вочевидь передбачається виділити деяку кінцеву частину списку для фактичних обчислень. Розглянемо приклад: функція take, яка виділяє перші n елементів списку: take1 :: [a]->Int->[a] take1 (s: sr) k = if k> 0 then s: take1 sr (k-1) else [] Тоді виклик take1 (numsFrom 0) 5 повертає [0, 1, 2, 3, 4].      Інший приклад використання циклічності – послідовність Фібоначчі, яка може ефективно обчислюватися як наступна нескінченна послідовність: fib = 1:1: [a+b | (a,b) <- zip fib (tail fib)] де zip – це функція зі Standard Prelude, яка повертає список пар елементів із двох своїх аргументів-списків: zip (x: xs) (y: ys) = (x, y) : zip xs ys zip xs ys = []      Варто зазначити, що нескінченний список fib визначений у термінах самого себе. Тоді виклик   take 5 fib дасть [1, 1, 2, 3, 5]. Ці обчислення можна проілюструвати на малюнку:   Функція error      У Haskell є вбудована функція error, тип якої String -> a. Ця функція повертає значення поліморфного типу (про який їй, на перший погляд, нічого не відомо).      Однак, існує одна величина, спільна для всіх типів: _|_. Семантично це точно те значення, яке завжди повертається функцією error (всі помилки мають значення «_|_»).      Ця функція корисна, коли необхідно перервати виконання програми, якщо щось пішло не так. Наприклад, визначення head із Standard Prelude має вигляд: head (x: xs) = x head [] = error “head{PreludeList}: head []”  Умовні вирази      Для визначення функції у мові Haskell можна використовувати умовні вирази. Наприклад, функція signum, що обчислює знак переданого їй аргументу, має вигляд: signum :: Int -> Int signum x = if x > 0 then 1                    else if x < 0 then -1 else 0 Умовний вираз записується у вигляді:     if умова then вираз else вираз. Умовою у визначенні умовного оператора є будь-який вираз типу Bool. При порівнянні можна використовувати наступні оператори:   <, >, <=, >= – оператори мають звичний зміст (наприклад, як в мові С),   = = –  оператор перевірки на рівність,   / = – оператор перевірки на нерівність.      Вирази типу Bool можна комбінувати за допомогою загальноприйнятих логічних операторів && та || (І та АБО), і функції заперечення not. Приклади допустимих умов: x >= 0 && x <= 10 x > 3 && x /= 10 (x > 10 || x < -10) && not (x == y)      Зрозуміло, можна визначати свої функції, що повертають значення типу Bool, і використовувати їх як умови. Наприклад, можна визначити функцію isPositive, що повертає True, якщо її аргумент невід'ємний, і False в іншому випадку: isPositive :: Int -> Bool isPositive x = if x > 0 then True else False Варто зазначити, що функцію isPositive можна визначити і простіше:   isPositive x = x > 0  Зіставлення зі зразком      As-зразки (as-patterns). Іноді зручно присвоїти зразку ім'я для використання у правій частині рівності. Наприклад, функція, що дублює перший елемент списку, може бути записана так:  f (x: xs) = x: x: xs      Зауважимо, що x: xs з'являється і як зразок у лівій частині рівності, і як вираз – у правій. Для поліпшення читабельності можна віддати перевагу запису x: xs тільки один раз; цього можна досягти, використовуючи as-зразок, як тут:  f s @ (x: xs) = x: s      З технічної точки зору, as-зразок завжди призводить до успішного зіставлення, хоча підзразки (в нашому випадку x: xs) можуть, звичайно, привести до невдачі.      Символи підстановки (wildcards). Часто зустрічається інша ситуація, коли зіставлення відбувається зі значенням, яке насправді не цікавить. head (x:_) = x tail (_: xs) = xs      Кожен символ підстановки (незалежно від інших) зіставляється з будьчим, але на відміну від формальних параметрів, зв'язування не відбувається; з цієї причини допускається наявність більш ніж одного «_» у даному рівнянні.  Семантика зіставлення зі зразком      Зіставлення зі зразком може завершитися невдачею (fail), успіхом (succeed), або бути відхиленим (diverge). Успішне зіставлення із зразком зв'язує формальні параметри зразка.      Відхилення відбувається, коли значення, необхідне для зразка, містить помилку (_|_).      Сам процес зіставлення відбувається «згори донизу, зліва направо». Невдача будь-де у цій функції призводить до невдачі всієї функції, після чого спроба зіставлення робиться для наступної функції.      Якщо всі функції приведуть до невдачі, значення застосування функції – _|_, що призводить до помилки виконання.      Шаблони верхнього рівня можуть також мати булеві запобіжники як функції, що дозволяють з'ясувати знак числа: sign x | x > 0 = 1        | x == 0 = 0        | x < 0 = -1 Варто зазначити, що для того самого зразка може бути передбачена ціла послідовність запобіжників; як і зразки, вони обчислюються зверху вниз, і перший з них, що повертає True, приведе до успішного зіставлення.  Операція вибору      У Haskell, як і в С++, крім оператора розгалуження є також оператор вибору.      Припустимо, необхідно визначити деяку функцію, яка повертає 1, якщо їй передано аргумент 0; повертає 5, якщо аргумент дорівнював 1; повертає 2, якщо аргумент дорівнює 2 і повертає –1 в решті випадків. У цьому випадку зручним виявляється оператор вибору: f x = case x of 0 -> 1 1 -> 5 2 -> 2    _ -> -1      Синтаксис оператора case очевидний; символ «_» аналогічний конструкції default у мові С++. Наведену вище функцію можна записати і таким чином: f x = case x of  {0 -> 1; 1 -> 5; 2 -> 2; _ -> -1 }      Такий спосіб явно задає групування та розділення конструкцій мови. Однак можна обійтися без нього.      Загальне правило таке. Після ключових слів where, let, do і of інтерпретатор вставляє відкриваючу дужку { та запам'ятовує колонку, в якій записана наступна команда.      Надалі перед кожним новим рядком, вирівняним на запам'ятовану величину, вставляється символ-роздільник ';'.      Якщо наступний рядок вирівняно менше (тобто його перший символ знаходиться ліворуч від запам'ятованої позиції), вставляється закриваюча дужка. Ліниві зразки      Лінивий зразок має вигляд ~pat. Ліниві зразки неспростовні, зіставлення значення «v» із зразком ~pat завжди успішне, незалежно від pat.      Іншими словами, якщо ідентифікатор з pat надалі буде використаний у правій частині, він буде пов'язаний або з відповідною частиною отриманого значення, якщо зіставлення «v» з pat завершиться успішно, або з _|_ в іншому випадку.      Ліниві зразки корисні в тих випадках, коли нескінченні структури даних визначаються рекурсивно. Розглянемо приклади.      Приклад 1. Клієнт client надсилає послідовність запитів (requests) до сервера server, а сервер відповідає на кожен запит відповіддю (response) певного типу.  Припустимо, сервер та клієнт мають наступну структуру: client init (resp:resps)=init:client (next resp) resps server (req:reqs) = process req : server reqs      Тут передбачається, що функція next визначає наступний запит на задану відповідь сервера, а функція process обробляє запит клієнта і повертає потрібну відповідь сервера. Однак, ця програма нічого не робитиме.      Проблема полягає в тому, що client, у тому вигляді, в якому він використовується в рекурсивних викликах reqs і resps, намагається виконати зіставлення зі зразком списку відповідей, перш ніж він отримає першу відповідь від сервера. Найкращим виходом є використання лінивого зразка: client init ~(resp:resps) =init:client (next resp) resps      Оскільки ліниві зразки неспростовні, зіставлення відразу виявляється успішним, дозволяючи «передати» початковий запит, що, в свою чергу, дозволяє згенерувати першу відповідь. Приклад 2: lazy :: [Int] -> Bool -> [Int] lazy ~(x:xs) isNull = if isNull then [] else [x] e4 = lazy [1,2] False e5 = lazy [] True e6 = lazy [] False e4 -> [1] e5 -> [] e6 -> Exception.  Вкладені форми      Часом необхідно створити вкладену область видимості усередині виразу, щоб породити локальні зв'язування, не видимі ззовні, – своєрідні «блочно-структурні» форми. Це можна зробити двома способами. 1. Let-вирази. В Haskell let-вирази зручно використовувати щоразу, коли потрібен вкладений набір зв'язувань. Розглянемо приклад:     e9 = let y = 2 :: Float          f x = (x+y)/y        in f 1 + f 2      Набір зв'язувань, що породжуються let-виразами, є взаємно рекурсивним, а зразки, що зв'язуються, трактуються як ліниві (тобто такі, що несуть неявну ~).      Єдиними 	допустимими 	видами 	оголошень 	є 	сигнатури 	типів, зв'язування функцій і зв'язування зразків. 2. Конструкція where. Іноді зручно поширити зв'язування на декілька функцій із запобіжниками, для цього використовується конструкція where. Розглянемо приклад: f :: Int -> Int -> String f x y | y > z = "y > x^2"       | y == z = "y = x^2"       | y < z = "y < x^2"   where      z = x * x Тоді виклик   f 3 5  дасть y < x^2      Такого ефекту не можна досягти використанням let-виразів, чия область видимості обмежена тими виразами, до яких вони входять.      Конструкція where має такі самі властивості й обмеження на зв'язування, як і вираз let.      Зауважимо, що при створенні конструкцій let та where можна використовувати явну нотацію. Наприклад:     e9 = let { y = 2 :: Float           ; f x = (x+y)/y}       in f 1 + f 2      Явна нотація корисна у випадку, коли бажано розмістити в одному рядку більше одного оголошення. Розглянемо приклад:   let y = a * b; z = a/b      f x = (x+y)/z   in f c + f d                          Стрілка вліво  Працює як оператор присвоєння: a <- createEntry x Це еквівалентно  a = createEntry(x)  2.4 Класи типів Класи типів та перевантаження      В мові Haskell існує спеціальний поліморфізм. Прикладами такого поліморфізму можуть бути: • числові оператори (наприклад, +) часто визначають як здатні працювати з різними видами чисел; • оператор рівності (= =) зазвичай працює з числами та багатьма іншими (але не всіма) типами.      Варто зазначити, що така перевантажена поведінка буде специфічною для кожного типу (фактично поведінка іноді не визначена або помилкова), у той час як для параметричного поліморфізму тип насправді не важливий (приміром, для функції length не важлива природа елементів списку).      У Haskell механізмом, що забезпечує керування спеціальним поліморфізмом (перевантаженням) є класи типів. Розглянемо приклад – оператор рівності.      Існує багато типів, для яких необхідно визначити рівність, проте є типи для яких цього робити не варто. Наприклад, порівняння на рівність функцій, взагалі кажучи, є обчислювально нерозв'язною задачею, тоді як задача порівняння двох списків виникає часто. (Зауважимо, що поняття рівності можна трактувати по-різному, тут йдеться саме про «рівність значень» на противагу «рівності вказівників», що має місце, наприклад, для оператора == Java. Рівність вказівників не є прозорою за посиланнями і тому погано підходить для функціональних мов).      Розглянемо наступне визначення функції elem, яка перевіряє входження до списку: x `elem` [] = False x `elem` (y: ys) = x == y | (x `elem` ys)      На перший погляд, тип elem повинен бути a -> [a] -> Bool. Однак із цього випливає, що = = має тип a -> a -> Bool, хоч як вже згадувалося, не варто визначати = = для всіх типів.      Більше того, якщо оператор = = був визначений для всіх типів, порівняння на рівність двох списків досить сильно відрізняється від порівняння двох чисел.      Класи типів вирішують перелічені проблеми. Вони дозволяють оголосити, які типи є втіленнями (instances) даного класу та дати визначення перевантажених операцій, пов'язаних із цим класом. Розглянемо приклад – клас типу, що містить оператор рівності: class Eq a where    (==) :: a -> a -> Bool      Тут Eq є собою іменем класу, що визначається, з єдиною операцією = =. Це оголошення може читатися так: «тип a є втіленням класу Eq, якщо для нього визначена (перевантажена) операція == підходящого типу».      Обмеження, що тип a може бути втіленням класу Eq, записується так: Eq a. Таким чином, Eq a не є виразом типу, але описує обмеження на тип і називається контекстом. Тепер можна визначити функцію elem, використовуючи клас Eq. Маємо: elem :: (Eq a) => a -> [a] -> Bool x `elem` [] = False x `elem` (y: ys) = x `eq` y | x `elem` ys      Тепер необхідно вказати, які типи є втіленням класу Eq, і задати специфічну поведінку = = для кожного з цих класів. Це роблять за допомогою оголошень втілень. Розглянемо приклад:   instance Eq Integer where    x == y = x `integerEq` y Таке визначення = = називається методом. Функція integerEq є «примітивною» функцією, що порівнює цілі значення на рівність, але в загальному випадку в правій частині рівності допускається довільний правильний вираз, так само як і у визначенні будь-якої іншої функції.      Розглянуте оголошення по суті означає: «тип Integer є втіленням класу Eq, і визначення методу, що відповідає операції = =». Аналогічно,   instance Eq Float where     x == y = x `floatEq` y дозволяє порівнювати числа з плаваючою крапкою, використовуючи = =.      Розглянемо приклад визначення функції, яка перевіряє наявність елемента в списку: class Eq1 a where   eq2 :: a -> a -> Bool  elem1 :: (Eq1 a) => a -> [a] -> Bool x `elem1` [] = False x `elem1` (y: ys) = x `eq2` y || x `elem1` ys  instance Eq1 Int where    x `eq2` y = abs (x-y) < 3  list1 :: [Int] list1 = [1,5,9,23]   e1 = 2 `elem1` list1 На екрані отримаємо True. Аналогічно можна чинити і з рекурсивними типами:  data Tree a = Leaf a | Branch (Tree a) (Tree a)  deriving Show instance (Eq a) => Eq (Tree a) where  (Leaf a) `eq` (Leaf b) = a `eq` b  (Branch l1 r1) `eq` (Branch l2 r2) = (l1 `eq` l2)  && (r1 `eq` r2)   _ `eq` _ = False      Запис instance (Eq a) => Eq (Tree a) where означає, що Eq (Tree a) – нащадок (Eq a)      Це означає, що можна перевіряти на рівність дерева, що зберігають об'єкти типу a, тоді і тільки тоді, коли відомо, як перевіряти на рівність об'єкти типу a. Отже, маємо: data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show  class Eq1 a where    eq2 :: a -> a -> Bool  instance Eq1 Int where    x `eq2` y = abs (x - y) < 3  instance (Eq1 a) => Eq1 (Tree a) where    (Leaf a) `eq2` (Leaf b) = a `eq2` b    (Branch l1 r1) `eq2` (Branch l2 r2) = (l1 `eq2` l2)  && (r1 `eq2` r2)     _ `eq2`_ = False  tree1,tree2 :: Tree Int tree1 = Branch (Leaf 1) (Leaf 2) tree2 = Branch (Leaf 2) (Leaf 1) e4 = tree1 `eq2` tree2 На екрані отримаємо True. У бібліотеці Prelude визначено клас Eq, який має вигляд  class Eq a where (==), (/=) :: a -> a -> Bool  x /= y = not (x == y)      Це приклад класу із двома операціями: одна для рівності, інша – для нерівності. Він також демонструє використання методу за замовчуванням, в нашому випадку для операції нерівності /=. Якщо в оголошенні втілення опустити метод для певної операції, тоді замість нього буде використовуватися метод за замовчуванням, визначений в оголошенні класу, якщо він існує.      Як вже було показано вище, у Haskell також підтримується поняття розширення класів (деякою мірою аналогічно спадкуванню в імперативних мовах).      Наприклад, можна визначити клас Ord, який успадковує всі операції з Eq, і додатково має набір операцій порівняння та функції визначення мінімуму та максимуму: class (Eq a) => Ord a where    (<), (<=), (>=), (>) :: a -> a -> Bool    max, min :: a -> a -> a      В такому випадку кажуть, що Eq є суперкласом відносно Ord (і навпаки, Ord є підкласом Eq), і будь-який тип, що є втіленням Ord, має бути також втіленням Eq. Розглянемо приклад: class Eq1 a where    eq2 :: a -> a -> Bool  class (Eq1 a) => Ord a where   lt,le :: a -> a -> Bool   x `le` y = x `eq2` y || x `lt` y  instance Eq1 Int where    x `eq2` y = abs (x - y) < 3  instance Ord Int where    x `lt` y = x < y + 1  i :: Int i = 3 e5 :: Bool e5 = i `lt` i На екрані отримаємо True.      Мова Haskell також допускає множинне спадкування, оскільки класи можуть мати більше одного суперкласу. Наприклад: class (Eq a, Show a) => C a where ... створює клас C, який успадковує операції і з Eq, і з Show.      У Haskell методи класів відносяться до оголошень верхнього рівня. Вони поділяють той самий простір імен, що і звичайні змінні; те саме ім'я не може одночасно використовуватися для позначення і методу класу, і змінної чи методу іншого класу.      Методи класу можуть містити додаткові обмеження класу для будь-якої змінної типу, за винятком тієї, що визначає поточний клас. Наприклад: class C a where   m :: Show b => a -> b Тут метод m вимагає, щоб тип b був із класу Show. Однак метод m не може накладати додаткових обмежень класу на тип a. Такі обмеження натомість мають бути частиною контексту в оголошенні класу.      У оголошенні класу можна використовувати типи вищого порядку, тобто типи функцій. Розглянемо приклад: class Functor f where   fmap :: (a -> b) -> f a -> f b      Зауважимо, що тип змінної f застосовується до інших типів в f a та f b. Таким чином, можна очікувати, що він буде зв'язуватися з деяким типом, так само як Tree, який може бути застосований до аргументу. Реалізація класу Functor для типу Tree може мати вигляд: instance Functor Tree where   fmap f (Leaf x) = Leaf (f x)         fmap f (Branch t1 t2) = Branch (fmap f t1) (fmap f t2) Таким чином, маємо: data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show Конструкція deriving неявно робить оголошення втілення Show. class Functor1 f where   fmap1 :: (a -> b) -> f a -> f b  instance Functor1 Tree where  fmap1 f (Leaf x) = Leaf (f x)  fmap1 f (Branch t1 t2) = Branch (fmap1 f t1) (fmap1 f t2)  tree1 = Branch (Leaf 1) (Leaf 2) e6 = fmap1 (+1) tree1 На екрані отримаємо Branch (Leaf 2) (Leaf 3)  Порівняння з ООП      Розглянемо аналогію класів типів у Haskell з об’єктно-орієнтованим підходом. Цю відповідність можна зобразити наступним чином: Haskell ООП Клас типу Клас Тип Об'єкт      Слід зазначити, що на відміну ООП, типи – це об'єкти, і, зокрема, відсутнє поняття про внутрішній стан об'єкта чи типу, що міг би змінюватися.      Перевага мови Haskell над деякими іншими ОО-мовами полягає в тому, що її методи цілком «типобезпечні»: будь-яка спроба застосувати метод до значення, чий тип не належить до необхідного класу, буде помічена при компіляції, а не під час виконання.      Розглянемо порівняння Haskell з іншими мовами програмування (на прикладі C++ та Java).      1. Haskell відокремлює визначення типу від визначення методів, пов'язаних із цим типом. Клас C++ або Java зазвичай визначає і структуру даних (змінні – члени класу), і функції, асоційовані з цією структурою (методи). У Haskell ці визначення даються окремо.      2. Метод класу, визначений у класі Haskell, відповідає віртуальній функції у класі мови C++. Кожне втілення класу забезпечує своє власне визначення для кожного методу, замовчування у класі відповідають реалізації за замовчуванням віртуальної функції у базовому класі C++.      3. Класи Haskell у грубому наближенні схожі на інтерфейси Java. Як і оголошення інтерфейсів, оголошення класів Haskell задають протокол використання об'єктів, а не визначення власне об'єкта.      4. Haskell не підтримує перевантаження в стилі C++, коли функції з різними типами поділяють загальне ім'я.      5. Для типів об'єктів у Haskell немає неявного приведення; відсутній універсальний базовий клас, на зразок Object, до якого можна приводити значення.      6. C++ та Java доєднують ідентифікуючу інформацію (таку, як таблиця віртуальних функцій) до представлення об'єкта під час виконання. У Haskell подібна інформація приєднується до значень логічно, а не фізично, через систему типів.      7. У систему класів Haskell не вбудовано контроль доступу (такої, як мітки public або private у визначенні класу). Натомість для приховування або відкриття компонентів слід користуватися системою модулів.  2.5 Задання типів через newtype та data Оголошення newtype      Ключове слово newtype вводить новий тип-обгортку. У нього може бути лише один конструктор з єдиним аргументом: Newtype Sum a = Sum a Це те саме, що і data Sum a = Sum a      Єдина відмінність полягає в тому, що у разі нового типу обчислювач не бачить різниці між Sum a і a. Її бачить лише компілятор. Це означає, що на розгортання і загортання такого значення в тип-обгортку не витрачається жодних зусиль. Такі типи підходять для вирішення двох завдань:      1. Більш точна перевірка типів. Наприклад, існують типи, які описують фізичні величини: вони є числами, але вони мають також і розмірності. Тоді можна написати: type Velocity = Double type Time = Double type Length = Double velocity :: Length -> Time -> Velocity velocity leng time = leng / time За таких умов, можна підставити на місце часу шлях і навпаки. Але за допомогою типів-обгорток ми можемо виключити такі випадки:    Newtype Velocity = Velocity Double    Newtype Time = Time Double    Newtype Length = Length Double    velocity :: Length -> Time -> Velocity    velocity (Length leng) (Time time) = Velocity $ leng / time      2. Визначення кількох екземплярів одного класу для одного типу. Наприклад, потрібно зробити два екземпляри для того самого типу Num a => a: Newtype Sum a = Sum a Newtype Prod a = Prod a Тоді можемо визначити два екземпляри для двох різних типів. Один для Sum: instance Num a => Monoid (Sum a) where   mempty = Sum 0   mappend (Sum a) (Sum b) = Sum (a + b) А інший для Prod:   instance Num a => Monoid (Prod a) where      mempty = Prod 1      mappend (Prod a) (Prod b) = Prod (a * b) Розглянемо приклад. newtype Natural = MakeNatural Integer deriving (Show, Eq)  toNatural :: Integer -> Natural toNatural x | x < 0 = error "Can't create  negative naturals!"             | otherwise = MakeNatural x  fromNatural :: Natural -> Integer fromNatural (MakeNatural i) = i  instance Num Natural where      fromInteger = toNatural      x + y = toNatural (fromNatural x + fromNatural y)      x - y = let r = fromNatural x - fromNatural y in                if r < 0 then error "Unnatural subtraction"                          else toNatural r      x * y = toNatural (fromNatural x * fromNatural y)      Без цього оголошення тип Natural не належатиме до класу Num. Втілення класу, оголошені для старого типу, не переносяться на новий.      Повна мета типу Natural полягає у створенні окремого втілення класу Num. Це було б неможливим, якщо Natural був визначений як синонім типу для Integer. e1 :: Natural e1 = toNatural 1 На екрані MakeNatural 1 e4 :: Natural e4 = (3 – 4) + 3 На екрані Exception Unnatural subtraction      Поведінка не зміниться, якщо замість оголошення newtype використовувати оголошення data.  Мітки полів (записи)      До полів усередині типу даних Haskell можна звертатися або за їхньою позицією, або по імені, за умови використання міток полів. Розглянемо тип даних, що описує точку на площині: data Point = Pt Float Float Дві координати точки типу Point – це перший та другий аргументи конструктора даних Pt. Функції, подібні до наступної: pointx :: Point -> Float pointx (Pt x _) = x можуть використовуватися як посилання на першу координату точки в більш описовому ключі, однак для великих структур створювати такі функції вручну накладно.      Конструктори в оголошенні data можуть бути оголошені з асоційованими іменами полів, вказаними у фігурних дужках. Ці імена ідентифікують компоненти конструктора за іменем, а не за позицією. Тоді тип Point можна визначити так:  data Point = Pt { pointx, pointy :: Float } Це визначення визначає два імені поля: pointx і pointy.       Такі імена полів можуть бути використані як функції-селектори, що вибирають компоненти структури. В нашому прикладі ці селектори мають вигляд:   pointx :: Point -> Float   pointy :: Point -> Float Розглянемо приклад: data Point = Pt {pointx, pointy :: Float} deriving Show absPoint :: Point -> Float absPoint p = sqrt (pointx p * pointx p + pointy p * pointy p)  e5 :: Point e5 = Pt {pointx = 1, pointy = 2} e6 :: Float e6 = absPoint e5 На екрані 2.236      Мітки полів поділяють простір імен верхнього рівня зі звичайними змінними та методами класів. Ім'я поля не може використовуватися для більш ніж одного типу даних у заданій області видимості.      Однак для певного типу даних те саме ім'я поля може використовуватися більш ніж в одному конструкторі, доки це поле має той самий тип для всіх випадків такого використання. Розглянемо приклад:  data T = C1 {f::Int, g::Float}              | C2 {f::Int, h::Bool} deriving Show  e9 :: T e9 = C1 {f = 1, g = 2} e10 :: T e10 = C2 {f = 3, h = False} e11 :: Int e11 = f e9 На екрані 1 e12 :: Int e12 = f e10 На екрані 3.   Строгі конструктори даних     Структури даних в Haskell, взагалі кажучи, є лінивими: компоненти не обчислюються, поки в них не виникає необхідність. На внутрішньому рівні кожне поле лінивого об'єкта даних обгорнуте в структуру, на яку зазвичай посилаються як на «перехідник», який інкапсулює обчислення, що визначають значення поля. Вхід в цей «перехідник» не здійснюється, поки значення не буде потрібне; «перехідник», який містить помилку (_|_), не впливає на інші елементи структури даних. Наприклад, в Haskell кортеж ('a', _|_) являє собою допустиме значення. Елемент 'a' може використовуватися без впливу на інші компоненти кортежу.      Більшість імперативних мов програмування є строгими, а не лінивими: всі компоненти структури даних перетворюються до їх значень, перш ніж вони будуть поміщені в структуру. З «перехідниками» пов'язаний ряд накладних витрат: на їх конструювання та обчислення витрачається час, вони займають місце в динамічній пам'яті, і також змушують збирач сміття зберігати інші структури, які потребують обчислення «перехідників». Щоб уникнути накладних витрат, в оголошенні data використовуються прапорці строгості. Вони дозволяють обчислювати поля конструктора негайно, вибірково подавлюючи лінивість. Поле, позначене «!» в оголошенні data, обчислюється при створенні структури, замість відкладання обчислення в «перехідник». Розглянемо приклад: data RealFloat a => Complex a =!a :+ !a Тут + є інфіксним конструктором. Це визначення позначає дві компоненти, дійсну і уявну частину комплексного числа, як строгі. Це більш компактне представлення комплексних чисел, але воно призводить до того, що комплексні числа з невизначеним компонентом, наприклад 1 :+ _|_, стають повністю невизначеними (_|_). Прапорець строгості ! може бути присутнім тільки в оголошенні data. Він не може використовуватися ні в інших сигнатурах типу, ні в жодних інших визначеннях типу. Ефекту строгості для аргументів функції можна досягти застосуванням функції seq або $!. Функція seq має вигляд: seq :: a -> b -> b і визначається формулами seq _|_b = _|_ seq a b = b, if a /= _|_ Оператор $! є строгим (викликається за значенням) застосуванням, він визначений в термінах seq. Prelude також містить визначення оператора $ для виконання нестрогих застосувань. Оператори $! і $ визначаються наступним чином: infixr 0 $, $!  ($), ($!) :: (a -> b) -> a -> b  f $ x = f x  f $! x = x `seq` f x     Наявність оператора нестрогого застосування $ може здаватися надмірним, оскільки звичайне застосування (f x) означає те ж саме, що (f $ x). Проте $ має низький пріоритет і праву асоціативність, тому іноді круглі дужки можна опустити, наприклад: f $ g $ h x = f (g (h x)) Розглянемо приклад застосування прапорця строгості: data HList a = Cons !a (HList a) | Nil deriving Show  hd (Cons x y) = x tl (Cons x y) = y  e10 :: HList Bool e10 = Cons True (Cons (error "e10") Nil) e11, e12 :: Bool e11 = hd e10 e12 = hd (tl e10) e13 :: HList Bool e13 = tl (tl (e10)) Результат має вигляд: e10 => Cons True *** Exception e10 e11 => True e12 => Exception e10 e13 => Exception e10 *** якщо прибрати прапорець строгості, то отримаємо Nil  2.6 Робота з введенням-виведенням та файлами Введення-виведення     Система введення-виведення в Haskell є чисто функціональною. Кожна дія введення-виведення повертає значення. В системі типів значення, що повертається, «помічено» типом IO, щоб відрізнятися від інших значень. Наприклад, тип функції getChar такий: getChar :: IO Char Тип IO Char вказує на те, що getChar, будучи викликаний, виконує деякі дії, які повертають символ. Розглянемо приклад: e1 = getChar Після введення символу, наприклад d, на екрані отримаємо 'd'     Дії, які нічого не повертають, використовують тип unit – (). Наприклад, функція putChar: putChar :: Char -> IO () Вона приймає символ як аргумент, але не повертає нічого змістовного. Тип unit схожий на тип void в інших мовах.     Дії збираються в послідовність за допомогою оператора: >>= (читається «зв'язати»). Цей оператор визначений в класі Monad. Приклад використання: e1 = putStr "x: " >> getLine >> = \l -> return (words l) Тут функція getLine пов'язана з лямбда функцією \l -> return (words l) Після введення *Main>e1 на екрані отримаємо  x: asdsafdsaf – рядок, що вводиться тоді на екрані маємо ["asdsafdsaf"]     Оператори зв'язування можна також трактувати як спосіб позбутися від проміжних змінних: doSomething >>= doSomethingElse >>= finishItUp Це еквівалентно запису x = doSomething() y = doSomethingElse(x) finishItUp(y) Іноді пишуть z <- finishItUp =<< doSomethingElse =<< doSomething Це буде еквівалентно x = doSomething() y = doSomethingElse(x) z = finishItUp(y) Оператор >> може розглядатися наступним чином: doSomething >> doSomethingElse що еквівалентно наступному імперативного коду: doSomething() doSomethingElse()     Замість прямого використання оператора >>= зазвичай використовується do-нотація, яка дозволяє приховати оператори, які монтують послідовність, за синтаксисом, схожим на загальноприйняті мови. Наприклад, буде коректним наступний код: e1=do putStr "x:"  l <- getLine  return (words l) Для do-виразів виконуються тотожності: do {e} = e do {e; stmts} = e >> do {stmts} do {p <- e; stmts} = let ok p = do {stmts} ok _ = fail "..." in e >> = ok do {let decls; stmts} = let decls in do {stmts} де stmts – деякі вирази. Пропуски "..." позначають повідомлення про помилку, що генерується компілятором, яке передається функції fail. Таким чином, ключове слово do вводить послідовність інструкцій, які виконуються в певному порядку.     Інструкція – це або дія (зразок зв'язується з результатом дії за допомогою <-), або множина локальних визначень, що вводяться з використанням let. Розглянемо програму, яка читає і друкує символ: main :: IO () main = do c <- getChar putChar c Інший приклад, виведення на екран рядка, що вводиться з клавіатури: main = do l <- getLine putStr l Використання імені main є важливим: main визначається як точка входу в програму на Haskell (аналогічно функції main в C) і повинна мати тип IO, зазвичай IO () (винятком є модуль Main).     Перша програма виконує дві дії послідовно: по-перше, вона читає символ, пов'язуючи результат зі змінною «c», по-друге, друкує символ. На відміну від виразу let, при використанні якого областю видимості змінної стає все визначення, змінні, визначені через <-, доступні тільки в наступних інструкціях. Розглянемо функцію ready, яка читає символ і повертає True, якщо символ – це «y»: ready :: IO Bool ready = do c <- getChar c == 'y' Наведена програма не працює, тому що друга інструкція в do – це просто логічне значення, а не дія. Необхідно взяти це булеве значення і створити дію, яка його повертає в якості свого результату. Функція return робить саме це: return :: a -> IO a Тоді, в попередньому прикладі, останній рядок повинен мати наступний вигляд: turn (c == 'y') Розглянемо функцію getLine: getLine :: IO String getLine = do c <- getChar if c == '\n' then return "" else do l <- getLine return (c:l) Кожне do вводить окремий ланцюжок інструкцій. Будь-яка конструкція, що «втручається», на зразок if, повинна використовувати нове do для ініціювання подальшої послідовності дій. Варто зауважити, що викликати деяку дію введення-виведення в звичайній функції не можна. Наприклад, функція: f :: Int -> Int -> Int, не здатна виконувати жодне введення-виведення, оскільки IO відсутнє в значенні, що вона повертає.  Програмування з діями     Дії введення-виведення є звичайними значеннями Haskell: їх можна передавати у функції, поміщати в структури і використовувати як будь-яке інше значення Haskell. Розглянемо приклад: todoList :: [IO ()] todoList = [putChar 'a', do putChar 'b' putChar 'c', do c <- getChar putChar c] Цей список насправді не викликає ніяких дій – він просто зберігає їх. Щоб з'єднати ці дії в єдину дію, можна використати функцію sequence_: sequence_ :: [IO ()] -> IO () sequence_ [] = return () sequence_ (a: as) = do a sequence_ as Наприклад, функція sequence_ може бути використана для конструювання putStr з putChar: putStr :: String -> IO () putStr s = sequence_ (map putChar s)  Обробка виключень     Помилки кодуються з використанням спеціального типу даних IOError. Цей тип представляє всі можливі виключення, які можуть статися всередині монади введення-виведення. Це абстрактний тип: користувачеві не доступний жоден конструктор для IOError. Наприклад, функція: isEOFError :: IOError -> Bool визначає, чи відбулася помилка через досягнення кінця файлу. Те, що IOError зроблений абстрактним, дозволяє додавати нові види помилок в систему без помітних змін типу даних. Тип обробника виключень – IOError -> IO a. Функція catch пов'язує обробник виключень з дією або множиною дій: catch :: IO a -> (IOError -> IO a) -> IO a Аргументами catch є дія і обробник. Якщо дія успішна, її результат повертається без виклику обробника. Якщо виникає помилка, вона передається в обробник як значення типу IOError, а потім викликається дія, пов'язана з обробником. Наприклад, getChar повертає символ нового рядка, коли виникає помилка: getChar1 :: IO Char getChar1 = getChar `catch` eofHandler where eofHandler e = if isEOFError e then return '\n' else ioError e     Використана тут функція ioError генерує виняток для наступного обробника виключень. Тип ioError: ioError :: IOError -> IO a Це схоже на return, за винятком того, що управління передається наступному обробнику переривань замість обробки наступної дії введення-виведення. Допустимі вкладені виклики catch, це призводить до вкладених обробникам винятків. Розглянемо приклад: getLine1 :: IO String getLine1 = catch getLine2 (\err -> return ("Error: " ++ show err)) where getLine2 = do c <- getChar1 if c == '\ n' then return "" else do l <- getLine1 return (c: l) Вкладені обробники виключень дозволяють getChar1 відслідкувати кінець файлу, тоді як будь-які інші помилки повернуть з getLine1 рядок, що починається з "Error:". Таким чином, виключення в Haskell можна розуміти наступним чином: trySomething x `catch` \(e :: IOException) -> handleError e або catch (trySomething x) (\(e :: IOException) -> handleError e) Аналог в С++ має вигляд try { trySomething (x)} catch (IOError e) {handleError (e)}   	 Файли     Відкриття файлу створює дескриптор (типу Handle), який використовується в транзакціях введення-виведення. Закриття дескриптора закриває пов'язаний з ним файл: type FilePath = String – шлях до файлу в файлової системі openFile :: FilePath -> IOMode -> IO Handle hClose :: Handle -> IO () data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode     Дескриптори також можуть бути пов'язані з каналами: комунікаційні порти не прив'язуються до файлів безпосередньо. Спочатку визначено кілька каналів, включаючи stdin (стандартний канал введення), stdout (стандартний канал виведення) і stderr (стандартний канал виведення повідомлень про помилки).     Операції введення-виведення символьного рівня включають hGetChar і hPutChar, які приймають дескриптор як аргумент. Тоді функція getChar може бути визначена наступним чином: getChar = hGetChar stdin Haskell також дозволяє повернути в єдиний рядок весь вміст файлу або каналу за допомогою функції getContents: getContents :: Handle -> IO String Функція getContents буде зчитувати з файлу по одному символу за раз в той момент, коли вони потрібні для обчислень. Розглянемо приклад, копіювання одного файлу в інший: main = do fromHandle <- getAndOpenFile "Copy from:" ReadMode toHandle <- getAndOpenFile "Copy to:" WriteMode contents <- hGetContents fromHandle hPutStr toHandle contents hClose toHandle putStr "Done." getAndOpenFile :: String -> IOMode -> IO Handle getAndOpenFile prompt mode = do putStr prompt name <- getLine catch (openFile name mode)  (\ _ -> do putStrLn ("Can not open" ++ name ++ "\ n") getAndOpenFile prompt mode)  Приклад роботи з введенням-виведенням Розглянемо задачу сортування масиву методом "бульбашки" на Haskell. import Array import Ix import IO --Наступна функція повертає елемент якщо відомий його номер в масиві indexArr :: (Ix i) => Array i e -> i -> e indexArr b i = b!i --Наступна функція змінює значення елемента з індексом i на значення e indexArrset::(Ix i) => Array i e -> i -> e -> Array i e indexArrset b i e = b//[(i, e)] --Наступна функція змінює елементи з номерами i і j місцями change :: (Ix i) => Array i e -> i -> i -> Array i e change b i j = indexArrset (indexArrset b i (indexArr b j)) j (IndexArr b i) --Наступна функція сортує масив методом бульбашки sort :: (Num e, Ix i, Ord e, Num i) => Array i e -> i -> i -> Array i e sort a m n = if n>= 1 then if m>= 1 then if a! m>a!n then sort (change a m n) (m-1) n else sort a (m-1) n else sort a (n-1) (n-1) else a --Наступна функція вводить символи типу Integer з клавіатури readNum :: IO Integer readNum = readLn --Наступна функція запитує елементи масиву, сортує їх, а потім виводить на екран input :: Array Integer Integer -> Int -> IO () input a x = if x<= 5 then do putStrLn "Guess a number (9 to end):" index <- readNum value <- readNum let c= indexArrset a index value print c if x == 5 then print (sort c 5 5) else input c (x + 1)      else return () a1 = array (1,5) ([(1,0),(2,0),(3,0),(4,0),(5,0)]) e3 = input a1 1   2.7 Стандартні класи та похідні втілення  Стандартні класи Haskell 1) Класи рівності і впорядкованості.     До класів цієї категорії відносяться класи Eq і Ord. Клас Eq має наступний вигляд: class Eq a where  (==), (/ =) :: a -> a -> Bool  x / = y = not (x == y)  x == y = not (x / = y) Клас Eq надає методи для порівняння на рівність (= =) і нерівність (/=). Всі основні типи даних, за винятком функцій і IO, є екземплярами цього класу. Клас Ord має наступний вигляд: data Ordering = EQ | LT | GT class (Eq a) => Ord a where  compare   :: a -> a -> Ordering  (<), (<=), (> =), (>)  :: a -> a -> Bool  max, min   :: a -> a -> a   compare x y | x == y = EQ  | x <= y = LT                 | otherwise = GT   x <= y = compare x y /= GT  x <y = compare x y == LT  x >= y = compare x y / = LT  x > y = compare x y == GT   max x y  | x <= y = y           | otherwise = x  min x y  | x <= y = x  | otherwise = y     Клас Ord використовується для повністю впорядкованих типів даних. Всі основні типи даних, за винятком функцій, IO і IOError, є екземплярами цього класу.  2) Клас Enum: class Enum a where succ, pred    :: a -> a toEnum  	  :: Int -> a fromEnum    :: a -> Int enumFrom    :: a -> [a]   -- [n ..] enumFromThen   :: a -> a -> [a]  -- [n, n'..] enumFromTo    :: a -> a -> [a]  -- [n..m] enumFromThenTo   :: a -> a -> a -> [a] --[n, n'.. m]     Клас Enum визначає операції над послідовно впорядкованими типами. Функції succ і pred повертають відповідно наступний і попередній елемент заданого значення. Функції fromEnum і toEnum перетворять відповідно значення типу Enum в тип Int і значення типу Int в тип Enum.     Методи, що починаються з enumFrom..., використовуються при перетворенні арифметичних послідовностей. Іншими словами, функції класу Enum мають вигляд: succ = toEnum. (+1). fromEnum pred = toEnum. (Subtract 1). fromEnum enumFrom x = map toEnum [fromEnum x ..] enumFromTo x y = map toEnum [fromEnum x .. fromEnum y] enumFromThenTo x y z = map toEnum [FromEnum x,  fromEnum y .. fromEnum z]  3) Класи Read і Show: type ReadS a = String -> [(a,String)] type ShowS = String -> String  class Read a where  readsPrec :: Int -> ReadS a  readList :: ReadS [a]  -- оголошення readList за замовчуванням дано в Prelude class Show a where  showsPrec :: Int -> a -> ShowS  show :: a -> String  showList :: [a] -> ShowS  showsPrec _ x s = show x ++ s  show x = showsPrec 0 x ""  -- оголошення для showList за замовчуванням дано в Prelude     Класи Read і Show використовуються для перетворення значень до типу рядок або перетворення рядків до інших значень. Всі типи Prelude, за винятком функціональних типів і типів IO, є екземплярами класів Show і Read.     Найпростішою функцією класу Show є show. Вона приймає довільну величину відповідного типу і повертає її представлення у вигляді рядка символів (списку символів). Наприклад, результатом show (2 + 2) буде 4.     Функція readList – парсер повертає одноелементний список, що містить значення типу a, яке було зчитано з вхідного рядка, і залишок рядка, який слідує за тим, який був синтаксично розібраний. Якщо синтаксичний розбір виявився неможливим, результатом буде порожній список, а якщо рядок можна розібрати декількома способами (неоднозначність), результуючий список буде містити більше однієї пари.     Для прикладу розглянемо функцію, яка представляє двійкові дерева у вигляді рядків, яка правильним чином позначає вкладені піддерева і розділяє ліві і праві гілки. showTree :: (Show a) => Tree a -> String showTree (Leaf x) = show x showTree (Branch l r) = "<" ++ showTree l ++ "|"  ++ showTree r ++ ">"     Розглянемо функцію-парсер для рядкового подання бінарних дерев, що породжується showsTree: readsTree :: (Read a) => ReadS (Tree a) readsTree ('<': s) = [(Branch l r, u) | (l, '|':t) <- readsTree s,      (r, '>':u) <- readsTree t] readsTree s = [(Leaf x, t) | (X, t) <- readsTree s]     Якщо перший символ рядку, що аналізується, – це '<', то маємо справу з поданням гілки (branch), в іншому випадку ми маємо справу з листом (leaf). У першому випадку для решти вхідного рядка s, що слідує за кутовою дужкою, яка відкривається, будь-який можливий синтаксичний розбір повинен бути tree Branch l r з рядком-залишком u.  Похідні втілення Раніше було розглянуто втілення Eq для дерев: Instance (Eq a) => Eq (Tree a) where (Leaf x) == (Leaf y) = x == y (Branch l r) == (Branch l 'r') = l == l '&& r == r' _ == _ = False Варто зазначити, що такі втілення можуть бути зроблені автоматично при оголошенні data:      data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Eq Конструкція deriving неявно робить оголошення втілення Eq.  Похідне втілення Ord для Tree є складнішим за втілення Eq: instance (Ord a) => Ord (Tree a) where   (Leaf _) <= (Branch _) = True   (Leaf x) <= (Leaf y) = x <= y   (Branch _) <= (Leaf _) = False   (Branch l r) <= (Branch l 'r') = l == l' || r <= r ' || l <= l'  2.8 Монади і функтори Монадні класи     Монада конструюється поверх поліморфного типу, такого як IO. Сама монада визначається оголошенням втілення, асоціюючи такий тип з одним або з усіма монадними класами: Functor, Monad і MonadPlus. Жоден з монадних класів не допускає утворення похідних втілень.      Крім IO, два інших типи з бібліотеки Prelude є членами монадних класів: списки ([]) і Maybe. З математичної точки зору монади управляються набором законів, які повинні виконуватися для монадних операцій. Ідея законів не специфічна для монад: Haskell включає інші операції, які, принаймні неформально, управляються законами. Наприклад, x /= y та not (x = = y) повинні повертати одне і те ж значення для будь-якого типу порівнюваних значень. Однак гарантії цього відсутні: і = =, і /= є окремими методами класу Eq, і немає способу переконатися в тому, що = = та /= пов'язані таким чином.     Клас Functor визначає одну операцію fmap. Функція відображення (map) застосовує операцію до об'єктів всередині контейнера (поліморфний тип може розглядатися як контейнер для значень іншого типу), повертаючи контейнер, структурно ідентичний вихідному. Монадні закони застосовуються до операції fmap в класі Functor: fmap id = id fmap (f. g) = fmap f. fmap g Ці закони гарантують, що структура контейнера не буде змінена fmap, і що вміст контейнера не буде переупорядкований в результаті відображаючої операції. Клас Monad визначає два основних оператора: >>= (зв'язування) і return. infixl 1 >>, >>= class Monad m where (>> =) :: m a -> (a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a fail :: String -> m a m >> k = m >> = \_ -> k Операції зв'язування (>> та >>=) комбінують два монадних значення, в той час як операція return вставляє значення в монаду (контейнер). Операція >>= комбінує монадне значення m a, що містить значення типу a, і функцію, яка приймає значення типу a, повертаючи монадне значення m b. Результатом є комбінування m a та m b в монадне значення, що містить b. Точний зміст зв'язування залежить від конкретної монади. Наприклад, в монаді IO зв'язування x >>= y послідовно виконує дві дії, передаючи результат першої дії в другу. Для інших вбудованих монад, списків і типу Maybe, ці монадні операції можуть розумітися в сенсі передачі нуля або більше значень з одного обчислення в наступне.     Синтаксична конструкція do забезпечує скорочену форму запису для ланцюжка монадних операцій. Сутність трансляції do може бути виражена двома наступними правилами: do e1; e2 = e1 >> e2 do p <- e1; e2 = e1 >> = (\ v -> case v of p -> e2; _ -> fail "s") де "s" – це рядок, який вказує місце розташування інструкції do для можливого використання в повідомленні про помилку. Закони, що керують >>= і return, мають вигляд: return a >>= k = k a m >>= return = m (M >>= f) >>= g = m >>= (\x -> f x >>= g)     Клас MonadPlus використовується для монад, які мають елемент нуль і операцію плюс: class (Monad m) => MonadPlus m where mzero :: m a mplus :: m a -> m a -> m a Елемент нуль підпорядковується наступним законам: m >>= \x -> mzero = mzero mzero >>= m = mzero Для списків значення нуль – це [ ], порожній список. Монада введеннявиведення не має нульового елемента і не належить цьому класу. Закони, що керують оператором mplus, наведені нижче: m `mplus` mzero = m mzero `mplus` m = m У монаді списку оператор mplus – це звичайний оператор конкатенації списків.  Вбудовані монади     У випадку списків монадне зв'язування викликає об'єднання набору обчислень для кожного елемента списку. При використанні зі списками, сигнатура >>= приймає наступний вигляд: (>>=) :: [a] -> (a -> [b]) -> [b] Тобто у випадку заданого списку елементів типу a і функції, що відображає a на список елементів типу b, зв'язування застосовує цю функцію до кожного вхідного a і повертає всі згенеровані списки b, сконкатеновані в один список.      Функція return створює одноелементний список. Таким чином, втілення класу Monad для списку має вигляд наступним чином: instance Monad [] where return :: a -> [a] return x = [x] -- створює список, що містить цей єдиний елемент (>>=) :: [a] -> (a -> [b]) -> [b] xs >>= f = concat (map f xs)     -- збирає всі результати f (які є списки) і комбінує їх в новий список Приклад 1: [10,20,30] >>= \x -> [x, x + 1] На екрані     [10,11,20,21,30,31] Приклад 2: [10,20,30] >>= \x -> [x, x + 1] >>= \y -> if y > 20 then [] else [y, y] На екрані     [10,10,11,11,20,20] Приклад 3: f x | x == '#' = "# #" | otherwise = "" "#" >>= f >>= f >>= f >>= f На екрані  "# #    # #         # #   # #                            # #    # #         # #    # # " Розглянемо приклад 4: [(X, y) | x <- [1,2,3], y <- [1,2,3], x /= y] Інший варіант: do x <- [1,2,3] y <- [1,2,3] True <- return (x / = y) return (x, y) Третій варіант: [1,2,3] >>= (\ x -> [1,2,3] >> = (\ y -> return (x /= y) >>= (\ r -> case r of True -> return (x, y) _-> fail ""))) Останнє визначення залежить від визначення методу fail в цій монаді як порожнього списку. По суті, кожна <- генерує набір значень, який передається в решту монадного обчислення. Приклад 5: mvLift2 :: (a -> b -> c) -> [a] -> [b] -> [c] mvLift2 f x y = do x '<- x  y '<- y return (f x 'y') Використання цієї функції має вигляд: mvLift2 (+) [1,3] [10,20,30] => [11,21,31,13,23,33] mvLift2 (\a b -> [a, b]) "ab" "cd" => [ "ac", "ad", "bc", "bd"] mvLift2 (*) [1,2,4] [] => []  Сенс монад і функторів     Перш за все варто зауважити, що монада – це контейнерний тип, над яким визначено кілька функцій. Монади моделюють різні види обчислень. Як і в списку, всі елементи, які містить монадний контейнер в будь-який момент часу, повинні бути одного типу.      Зазвичай Haskell використовує пару функцій return і bind (>>=), але іноді простіше розглянути функції map (fmap), return та join. Функцію bind можна визначити в термінах map (fmap), return і join.     Як відомо, функція map (fmap в Haskell 98) випливає з визначення функтора. Можна думати про функтор як про тип контейнера, в якому можна застосувати єдину функцію до кожного об'єкту. Тобто, якщо f – функтор, і є функція типу (a -> b), і контейнер типу (f a), то можна отримати новий контейнер типу (f b). Це очевидно з типу fmap:      fmap :: (Functor f) => (a -> b) -> f a -> f b (можна розшифрувати це так: Якщо ви дасте мені ягоду лохини за кожне яблуко, яке я дам вам (a -> b), і у мене є коробка яблук (f a), то це значить, що я отримаю коробку з лохиною (f b)). Кожна монада є функтором.     Метод return специфічний для монад. Якщо m – монада, тоді return приймає елемент типу a, і повертає контейнер типу (m a) з цим елементом в ньому. Таким чином, її тип в Haskell  return :: (Monad m) => a -> m a (можна розшифрувати це так: Якщо у мене є яблуко (a), то я можу покласти його в коробку (m a)).     Метод join специфічний для монад, він приймає контейнер контейнерів m (m a), і комбінує їх в один m a певним осмисленим чином. join :: (Monad m) => m (m a) -> m a (можна розшифрувати це так: Якщо у мене є коробка коробок яблук (m (m a)), то я можу взяти яблука з кожної, і покласти їх в нову коробку (m a))     Використовуючи ці методи, можна сконструювати важливу операцію, що називається bind або extend, яка зазвичай позначається символом (>>=). Функція bind бере контейнер типу (m a) і функцію типу (a -> m b). Спочатку вона відображає функцію на контейнер (що дасть m (m b)) і потім застосовує join, повертаючи контейнер типу (m b). (>>=) :: (Monad m) => m a -> (a -> m b) -> m b xs >>= f = join (fmap f xs) (можна розшифрувати це так: Якщо у мене є коробка яблук (m a), і для кожного яблука, ви дасте мені коробку лохини (a -> m b) тоді я зможу отримати коробку з усіма ягодами лохини (m b))  2.9 Модулі та абстрактні типи даних Модулі      Програма на Haskell складається з колекції модулів. Модуль в Haskell використовується для досягнення двох цілей: для управління просторами імен і для створення абстрактних типів даних. На верхньому рівні модуль оголошення: оголошення пріоритетів, оголошення data і type, оголошення класів і втілень, сигнатури типів, визначення функцій і зв'язування шаблонів. Модулі мають алфавітно-цифрові імена, які повинні починатися з літери у верхньому регістрі. Формальний зв'язок між модулем Haskell і файловою системою, яка (як правило) забезпечує його підтримку, відсутній. Зокрема, немає зв'язку між іменем модуля й іменем файлу, і більше одного модуля можуть імовірно перебувати в одному файлі. Технічно, модуль являє собою одне велике оголошення, яке починається з ключового слова module. Розглянемо приклад: module Tree (Tree (Leaf, Branch), fringe) where data Tree a = Leaf a | Branch (Tree a) (Tree a) fringe :: Tree a -> [a] fringe (Leaf x) = [x]          fringe (Branch left right) = fringe left ++ fringe right Цей модуль явно експортує Tree, Leaf, Branch і fringe. Якщо список експорту, який слідує за ключовим словом module, опущений, всі імена, доступні на верхньому рівні модуля, будуть експортовані. Слід зазначити, що ім'я типу та його конструктори групуються разом, як в Tree (Leaf, Branch). В якості скорочення можна написати Tree(..). Є припустимим також експортувати тільки частину конструкторів. Ім'я в списку експорту не повинно бути локальним по відношенню до експортованого модуля, будь-яке ім'я в області видимості може бути включено в список експорту. Модуль Tree може тепер бути імпортований в деякий інший модуль: module Main (main) where import Tree (Tree (Leaf, Branch), fringe) main = print (fringe (Branch (Leaf 1) (Leaf 2))) Різні елементи, імпортовані в модуль або експортовані з модуля, називаються сутностями (entities). В даному випадку вказаний явний список імпорту в оголошенні import; якщо опустити його, то це призведе до імпорту всіх сутностей, що експортуються з Tree.  Кваліфіковані імена     При імпортуванні сутностей з одного модуля в інший може виникнути проблема, якщо будуть збігатися імена імпортованої сутності і сутності, що  присутня в модулі. Haskell вирішує її, дозволяючи використовувати кваліфіковані імена. Декларація імпорту може використовувати ключове слово qualified, при цьому імпортовані імена повинні використовувати ім'я імпортованого модуля в якості префікса. За такими префіксами повинен слідувати символ «.». Розглянемо приклад:      module Fringe (fringe) where import Tree (Tree (..)) fringe :: Tree a -> [a] Інше визначення fringe:      fringe (Leaf x) = [x] fringe (Branch x y) = fringe x module Main where import Tree (Tree (Leaf, Branch), fringe) import qualified Fringe (fringe) main = do print (fringe (Branch (Leaf 1) (Leaf 2))) print (Fringe.fringe (Branch (Leaf 1) (Leaf 2)))  Абстрактні типи даних     Крім управління просторами імен, модулі забезпечують єдиний в Haskell шлях для створення абстрактних типів даних (ADT). Ключовою властивістю ADT є те, що представляючий тип виявляється прихованим; всі операції над ADT 	здійснюються 	на 	абстрактному 	рівні, який 	не залежить 	від представлення. Наприклад, для типу Tree відповідний ADT міг би включати наступні операції: data Tree a -- тут вказується тільки ім'я типу leaf :: a -> Tree a branch :: Tree a -> Tree a -> Tree a cell :: Tree a -> a left right :: Tree a -> Tree a isLeaf :: Tree a -> Bool Модуль, який підтримує цей ADT, має вигляд: module TreeADT (Tree, leaf, branch, cell, left, right, isLeaf) where data Tree a = Leaf a | Branch (Tree a) (Tree a) leaf = Leaf branch = Branch cell (Leaf a) = a left (Branch l r) = l right (Branch l r) = r isLeaf (Leaf _) = True isLeaf _ = False  Розглянемо приклад: module A (f) where f :: Int-> Int f x = x + x  module B (f) where f :: Int-> Int f x = x * x  module Main where import B (f) main :: IO ()          main = putStrLn $ show $ f $ 10 На екрані отримаємо 100. module Main where import A (f) main :: IO () main = putStrLn $ show $ f $ 10 На екрані отримаємо 20. Тут f – абстрактний тип. Інші властивості модулів: • Оголошення import може вибірково приховувати суті при використанні конструкції hiding в оголошенні імпорту. Це корисно для явного виключення імен, які використовуються для інших цілей, при цьому відпадає необхідність використання кваліфікаторів для інших імпортованих з цього модуля імен. • Оголошення import може містити as для вказівки кваліфікатора, відмінного від імені імпортованого модуля. Це можна використовувати для скорочення кваліфікаторів з модулів з довгими іменами або для того, щоб не змінювати всі кваліфіковані імена в разі зміни імені модуля.  2.10 Робота з масивами Масиви      Масиви в функціональній мові слід розглядати просто як функції з індексів в значення. Будь-який модуль, який використовує масиви, повинен імпортувати модуль Array. Бібліотека Ix визначає клас типу для індексів масиву: class (Ord a) => Ix a where range :: (a, a) -> [a] index :: (a, a) a -> Int inRange :: (a, a) -> a -> Bool Оголошення втілень забезпечуються для типів Int, Integer, Char, Bool і кортежів типів Ix до 5 елементів. Крім того, похідні втілення можуть бути автоматично створені для типів перелічень і кортежів. Зазначені примітивні типи розглядаються як індекси вектора, а кортежі – як індекси для багатовимірних прямокутних масивів.     Варто зауважити, що перший аргумент кожної операції класу Ix – це пара індексів; вона зазвичай задає межі масиву. Наприклад, межами 10елементного масиву з відліком від 0 і індексами типу Int буде пара (0,9), а матриця 100 на 100 з відліком від 1 може мати межі ((1,1), (100,100)).     Операція range приймає пару границь і створює впорядкований список індексів, що лежать між цими границями. Наприклад, range (0,4) => [0,1,2,3,4] range ((0,0), (1,2)) => [(0,0), (0,1), (0,2), (1,0), (1,1), (1, 2)] Предикат inRange визначає, чи лежить індекс всередині заданої пари границь.  Нарешті, операція index дозволяє адресувати певний елемент масиву: index (1,9) 2 => 1 index ((0,0), (1,2)) (1,1) => 4     Функція створення монолітного масиву в Haskell формує масив по його границям і списку пар індекс-значення: array :: (Ix a) => (a, a) -> [(a, b)] -> Array a b Наприклад, визначення масиву квадратів чисел від 1 до 100:     squares = array (1,100) [(i, i * i) | i <- [1..100]] Звернення до елементу масиву за індексом виконується за допомогою інфіксного оператора «!», а межі масиву можуть бути отримані з функції bounds: squares!7 => 49 bounds squares => (1,100) Приклад: mkArray :: (Ix a) => (a -> b) -> (a, a) -> Array a b mkArray f bnds = array bnds [(i, f i) | i <- range bnds]     Багато масивів визначаються рекурсивно, тобто зі значеннями одних елементів, які залежать від значень інших: fibs :: Int -> Array Int Int fibs n = a where a = array (0, n) ([(0, 1), (1, 1)] ++ [(i, a!(i-2) + a!(i-1))  | i <- [2..n]])  Акумуляція     Можна послабити обмеження на одноразову появу індексу в асоціативному списку, вказавши спосіб комбінування множини значень, асоційованих з одним індексом; результат називається акумульованим масивом: accumArray :: (Ix a) => (b->c-> b) -> b -> (a, a) -> [(a, c)]     -> Array a b Перший аргумент accumArray – це акумулююча функція, другий – початкове значення (одне й те саме для кожного елемента масиву), а аргументи, що залишилися, – це границі і асоціативний список, як у функції array.      Зазвичай акумулююча функція – це (+), а початкове значення – нуль; наприклад, наступна функція приймає пару границь та список значень і створює таблицю числа появ кожної величини всередині границь: hist :: (Ix a, Integral b) => (a, a) -> [a] -> Array a b hist bnds is = accumArray (+) 0 bnds [(i, 1) | i <- is,  inRange bnds i]  Інкрементальні оновлення     Крім функції створення монолітного масиву, в Haskell є функція інкрементального оновлення масиву, що записується як інфіксний оператор //. У найпростішому випадку зміна i-го елемента масиву a на v записується так: a // [(i, v)]. (//) :: (Ix a) => Array a b -> [(a, b)] -> Array a b Розглянемо приклад – множення матриць. matMult :: (Ix a, Ix b, Ix c, Num d) =>      Array (a, b) d -> Array (b, c) d -> Array (a, c) d  matMult x y = array resultBounds [((I, j), sum [x! (I, k) * y! (K, j) | k <- range (lj, uj)]) | i <- range (li, ui), j <- range (lj ', uj')] where ((Li, lj), (ui, uj)) = bounds x      ((Li ', lj'), (ui ', uj')) = bounds y resultBounds | (Lj, uj) == (li ', ui') = ((li, lj '), (ui, uj')) | otherwise = error "matMult: error "  Тип Maybe Конструктор типу Maybe визначено в Prelude наступним чином: data Maybe a = Nothing | Just a Призначення типу Maybe полягає в тому, щоб надати метод обробки неправильних або необов'язкових значень без завершення програми, що сталося б, якби використовувалася функція error, і без використання функції IOError з монади IO, яка вимагала б, щоб вислів став монадним.     Бібліотека Maybe має вигляд: isJust :: Maybe a -> Bool isJust (Just a) = True isJust Nothing = False  isNothing :: Maybe a -> Bool isNothing = not . isJust  fromJust :: Maybe a -> a fromJust (Just a) = a fromJust Nothing = error "Maybe.fromJust: Nothing"  fromMaybe :: a -> Maybe a -> a fromMaybe d Nothing = d fromMaybe d (Just a) = a  maybeToList :: Maybe a -> [a] maybeToList Nothing = [] maybeToList (Just a) = [a]  listToMaybe :: [a] -> Maybe a listToMaybe [] = Nothing listToMaybe (a: _) = Just a     catMaybes :: [Maybe a] -> [a] catMaybes ms = [m | Just m <- ms]     mapMaybe :: (a -> Maybe b) -> [a] -> [b] mapMaybe f = catMaybes . map f     Nothing можна інтерпретувати як None. Тому, isNothing x перевіряє, що x is None. Протилежність Nothing – Just. Наприклад, isJust x перевіряє, що x is not None. Розглянемо приклад: maybe someDefault (\x -> ...) mx На С ++ це виглядало би як if (mx is None) { x = someDefault} else {x = mx ...} Більш специфічний варіант для випадку, коли null – це помилка: maybe (error "bad value!") (\ x -> ...) x На Python маємо: if (x is None) raise Exception ("bad value!")  2.11 Додаткові теми по Haskell Монада State      Обчислення, що бере певне початкове значення (типу s) і повертає кортеж, що містить результуюче значення обчислення (типу a) і новий стан (типу s), може бути виражено функцією вигляду s -> (a, s).      Наприклад, \s -> ( "foo", s) може бути обчисленням, яке повертає "foo" як результуюче значення і не змінений стан. Для абстрагування можна обернути ці обчислення в наступний тип: data State s a = State {runState :: s -> (a, s)}  Функція runState     Функція runState приймає стан обчислення і початкове значення в якості параметрів. Вона «витягає» обчислення з типу State і просто застосовує його до початкового значення. runState :: State s a -> s -> (a, s) runState (State f) s = f s  Функції get, put, return get – це «обчислення зі змінним станом, яке повертає сам стан». get :: State s s get = State $ \ s -> (s, s) put – це «обчислення зі змінним станом, що не повертає нічого, проте змінює стан». put :: s -> State s () put s '= State $ \s -> ((), s') return a – повертає обчислення зі станом, завжди повертає вказане значення «a».  Розглянемо приклад – обчислення n!. Реалізація без монади State: factorial :: (Integral a) => a -> a factorial 0 = 1 factorial n = n * factorial (n - 1) Реалізація з монадою State: import Control.Monad.State factorl :: Int-> State Int Int -- тип стану – Int, тип результату – теж Int factorl 0 = do acc <-get -- отримуємо накопичений результат      return acc -- повертаємо його factorl n = do acc <- get -- отримуємо акумулятор      put (acc * n) -- домножуємо його на n і зберігаємо factorl (n-1) -- продовжуєм обчислення факторіала fact :: Int-> Int fact n = fst $ runState (factorl n) 1 main = putStrLn $ show $ fact 5     Починаючи з версії 2.0.0.0 і вище пакета mtl змінилася реалізація монади State: модуль Control.Monad.State більше не експортує конструктор State. Потрібно замінити цей конструктор функцією state :: (s -> (a, s)) -> State s a, яка робить ту ж саму роботу.  Монада ST     Дана монада знаходиться в модулі Control.Monad.ST. Монада ST реалізує роботу зі змінним станом, але в абсолютно функціональному стилі, зберігаючи всі важливі властивості і принципи функціональної парадигми: незалежність результату від порядку обчислень, прозорість посилань, лінивість, можливість вилучення об'єктів з монади ST (тобто, можливість отримати «чисте» значення в результаті обчислення зі станом у монаді ST). Тобто монада ST здійснює роботу з пам'яттю в функціональному стилі. Іншими словами, в мові Haskell є чисто функціональний інструмент для ефективного вирішення імперативних завдань. У даного типу є два параметри і немає конструкторів: data ST s a Тут тип a повертається «дією» типу s. Сигнатура функції, що дозволяє отримати значення з монади ST, має вигляд runST :: (forall s . ST s a) -> a Аналогом квантора загальності є forall. Розглянемо приклад: map :: forall a, b . (A-> b) -> [a] -> [b] Це означає, що map є поліморфним алгоритмом, який можна спеціалізувати будь-якими значеннями цих a і b. Наприклад, її можна використовувати в контексті, що вимагає функції типу (Int -> Int) -> [Int] -> [Int] або вимагає функції типу (Char -> Bool) -> [Char] -> [Bool]. forall також можна використовувати для визначення нового типу. Наприклад, визначимо тип: data GeoObject = forall a . Figure a => GeoObject a Тоді за допомогою типу GeoObject можна визначити неоднорідний список об'єктів, що складають географічну карту: geolist :: [GeoObject] geolist = [GeoObject (Point (0, 0)), GeoObject (Line (1, 1) (2, 2)), GeoObject (Polygon [(1, 1), (1, -1), (-1, - 1), (-1, 1)]), GeoObject (Ellipse (0, 0) 1 + 1)]     Для використання forall необхідно підключити мовні розширення, скориставшись командою {-# LANGUAGE ExistentialQuantification #-} Також для типу ST визначено ряд методів: newSTRef :: a -> ST s (STRef s a) readSTRef :: STRef s a -> ST s a writeSTRef :: STRef s a -> a -> ST s () Це функції запису в іменований стан, читання і зміни. Проілюструємо на прикладах. Приклад 1. import Data.STRef import Control.Monad import Control.Monad.ST productST :: Num a => [a] -> a productST xs = runST $ do n <- newSTRef 1 mapM_ (\x -> modifySTRef n (* x)) xs readSTRef n Результат виконання цієї послідовності знаходиться в монаді ST, тому для отримання «чистого» значення з цієї монади використовується функція runST. Перша дія – запис в іменований стан n початкового значення 1. Далі виконуються циклічні обчислення за допомогою функції mapM_, для кожного елемента x зі списку xs виконується дія modifySTRef n (* x). Ця дія модифікує значення «змінної» n за допомогою заданої функції (* x). Імперативний аналог цього фрагмента коду – n = n * x. Приклад 2. Реалізація циклу for: result forLoop (result init, int begin) { result s = init; for (i = begin; i <n; i ++) update (i, s); return s; } На Haskell цей цикл матиме наступний вигляд: import Control.Monad import Data.STRef import Control.Monad.ST forLoop :: i -> (i -> Bool) -> (i -> i) -> (i -> s -> s) -> s  -> s forLoop i0 pred next update s0 = RunST $ do refI <- newSTRef i0 refS <- newSTRef s0 iter refI refS readSTRef refS where iter refI refS = do i <- readSTRef refI s <- readSTRef refS when (pred i) $ do writeSTRef refI $ next i writeSTRef refS $ update i s iter refI refS Функція when – це стандартна функція з модуля Control.Monad. Вона перевіряє предикат, і якщо він повертає True, виконує серію дій, в яких записуються оновлені значення. Виклик цієї функції може мати вигляд: Prelude> forLoop 1 (<= 10) succ (+) 0 На екрані 55. Приклад 3. Цикл while: result whileLoop (result begin) { result s = begin; while (pred (s)) update (s); return s; } На Haskell даний цикл має наступний вигляд: whileLoop :: (s -> Bool) -> (s -> s) -> s -> s whileLoop pred update s0 = RunST $ do ref <- newSTRef s0 iter ref readSTRef ref where iter ref = do s <- readSTRef ref when (pred s) $ do writeSTRef ref $ update s iter ref Використання даної функцію має вигляд: Prelude> whileLoop ((>0). fst)  (\(n, s) -> (pred n, n + s)) (10, 0) Результат (0,55).  Розширення     Розширення підключаються за допомогою спеціального коментаря. Такий коментар називається прагмою (pragma). Він поміщається на початку модуля. Розширення діє тільки в поточному модулі. {-# LANGUAGE ExtentionName1, ExtentionName2, ExtentionName3 #-}     1. Прагма LANGUAGE. Слово LANGUAGE говорить компілятору про те, що ми хочемо скористатися розширеннями з іменами ExtentionName1, ExtentionName2, ExtentionName3.     2. Прагма INLINE. Дана прагма вказує компілятору на те, що на етапі спрощення програми необхідно замінити виклик функції на її праву частину. Цей процес називають вбудовуванням функцій. Заміна буде проведена тільки в разі повного застосування функції, якщо синтаксична арність (кількість аргументів зліва від знаку рівності) збігається з числом переданих у функцію аргументів. Приклад: {-# INLINE (.) #-} (.) :: (b -> c) -> (a -> b) -> a -> c (.) f g = \x -> f (g x)     3. Прагма RULES. За допомогою даної прагми можна визначати специфічні для застосування правила оптимізації. Наприклад, додаткові правила для функції map. {-# RULES "map/compose" forall f g x. map f (map g x) = map (f . g) x "map/id" map id = id # -} Першим в лапках йде ім'я правила. Воно використовується тільки для підрахунку статистики (приміром, якщо необхідно дізнатися, скільки правил спрацювало в даному прогоні програми). За ім'ям правила пишеться рівняння. В одній прагмі може бути кілька рівнянь. Правила розділяються крапкою з комою або переходом на інший рядок. Всі вільні змінні правила перераховуються в оточенні forall (...). Відбувається тільки перевірка типів. Ніяких інших перевірок не проводиться.     Слід зазначити, що прагма RULES застосовується до тих пір, поки є можливість її застосовувати, при цьому можна увійти в нескінченний цикл: {-# RULES "infinite" forall a b. f a b = f b a #-}     4. Прагма UNPACK. Прагма UNPACK дозволяє нам боротися з зайвими об'єктами типу CON (об'єкти купи). Значення в Haskell містять додаткову службову інформацію, яка необхідна на етапі обчислення, наприклад, значення спочатку було відкладеним, потім до нього дісталися і порахували, можливо воно виявилося не визначеним значенням (undefined). Такі значення називаються запакованими (boxed). Незапаковане значення – це примітивне значення, як воно представлено в пам'яті комп'ютера. Наприклад, визначення цілих чисел: data Int = I# Int# Всі незапаковані значення пишуться з решіткою на кінці. Запаковані значення дозволяють відкладати обчислення, користуватися undefined при визначенні функції. Однак в цьому випадку збільшується витрата пам'яті.      За допомогою прагми UNPACK можна відмовитися від лінивої гнучкості на користь меншої витрати пам'яті. Ця прагма дозволяє вбудовувати один конструктор в поле іншого. Це поле повинно бути строгим (з поміткою !) і мономорфним (тип поля повинен бути конкретним типом, а не параметром), причому підлеглий тип має містити лише один конструктор (у нього немає альтернатив): data PairInt = PairInt {- # UNPACK #-}! Int {- # UNPACK #-}! Int В стандартних бібліотеках передбачено багато незапакованих типів. Зокрема, це спеціальні кортежі. Вони пишуться з решітками: data ST s a = ST (STRep s a) type STRep s a = State # s -> (# State# s, a #)    Тут (# .... #) – спеціальні кортежі. Спеціальні кортежі використовуються для повернення декількох значень безпосередньо, без створення проміжного кортежу в купі. У цьому випадку значення будуть збережені в регістрах або на стеку.  	 Завдання з Haskell 1. На шахівниці розміром n×n на заданому полі стоїть шаховий кінь. Знайдіть такий шлях коня на шахівниці, щоб у кожній клітинці він побував єдиний раз. Кінь ходить за звичайними шаховими правилами.  2. Створіть багатошаровий персептрон з навчанням методом зворотного поширення помилки. Перевірте його роботу на прикладі обчислення XOR. 3. Розв’яжіть задачу комівояжера, використовуючи генетичний алгоритм. 4. Використовуючи бібліотеку для роботи з базами даних HaskellDB, створіть програму з графічним інтерфейсом, яка виводить вміст таблиці з БД і дозволяє його змінювати. 5. Для заданого зв’язного графу визначити всі шляхи з однієї обраної вершини до іншої. 6. Створіть чат з графічним інтерфейсом. Використайте сокети та бібліотеку qtHaskell. 7. Використовуючи веб-фреймворк Happstack, реалізуйте програму, що генеруватиме таблицю за переданими заданими параметрам: заголовок, кількість рядків та стовпців, колір тла. 8. Використовуючи OpenGL, створіть додаток на Haskell, що моделює зіткнення двох куль. 9. Стеганографія – приховування змісту повідомлення без явних ознак наявності цього повідомлення. Зокрема, можна вбудовувати інформацію у графічні файли без помітних змін в зображенні (нижче порогу чутливості людини). Напишіть програму для приховування інформації у GIF-файлі: приховані дані будуть записуватися в останній значущий біт (метод LSB – Least Significant Bit). Використовуйте графічну бібліотеку GD. 10. Створіть Haskell-додаток для ініціалізації масиву об'єктів інформацією з файлу XML. Здійсніть перевірку XML-документа із залученням DTD та XSD. Для роботи з XML використайте бібліотеку HaXML. Створіть файл XML та відповідне йому DTD-визначення наступної тематики: тарифи мобільних компаній. Має бути описано 4–5 тарифів.  Тарифи мобільних компаній можуть мати таку структуру: • Name – назва тарифу. • Operator name – назва мобільного оператора, якому належить тариф. • Payroll – абонентська плата на місяць (0 – n гривень). • Сall prices (має бути декілька) – ціни на дзвінки: всередині мережі (0 – n гривень за хвилину), на інші мобільні мережі (0 – n гривень за хвилину), на стаціонарні телефони (0 – n гривень за хвилину). • SMS price – ціна за смс (0 – n гривень). • Parameters (має бути декілька) – наявність улюбленого номера (0 – n), спосіб тарифікації (посекундна, похвилинна), плата за підключення до тарифу (0 – n гривень) тощо. Кореневий елемент називається Tariff.      Частина ІІІ. Лямбда-числення 3.1 Вступ до λ-числення. Обчислення виразів Лямбда-числення      Лямбда-числення (або λ-числення) – формальна система, що використовується для дослідження визначення функції, застосування функції та рекурсії. Це числення було запропоноване Алонсо Чорчем (Alonzo Church) та Стівеном Кліні (Stephen Kleene) в 1930-ті роки як частина намагання розробити базис математики на основі функцій, а не множин (однак спроба уникнути перешкод, таких як парадокс Рассела, все одно виявилася неуспішною). Незважаючи на це, лямбда-числення стало зручним інструментом в дослідженні обчислюваності функцій та лягло в основу парадигми функціонального програмування.      Як і машину Тьюрінга, лямбда-числення можна розглядати як ідеалізовану, мінімалістичну абстракцію (мову програмування), здатну визначати будь-який алгоритм. Відмінність між ними полягає в тому, що лямбда-числення відповідає функціональній парадигмі визначення алгоритмів, а машина Тьюрінга – імперативній: машина Тьюрінга має певний «стан», що може змінюватись із кожною наступною інструкцією, лямбдачислення має справу з функціями, котрі отримують значення параметрів та повертають результати обчислень (можливо, інші функції), але не спричиняють зміни вхідних даних. Лямбда-числення – це обчислення анонімних (безіменних) функцій: • по-перше, воно дає метод представлення  функцій;• по-друге, множину правил виведення для синтаксичного перетворення функцій.Розглянемо просту функцію:func x = 2 * x      Щоб уявити цю функцію в нотації лямбда-числення, необхідно опустити ім'я функції "func", роблячи її анонімною. Вона буде представлена в вигляді λ-виразу наступним чином:λx. * 2x (або \ x. * 2x) Використання вбудованих функцій записується в префіксному порядку.Такий лямбда-вираз можна читати: символ λ, як «функція від чого», і крапку (.), як «яка повертає». Лямбда-вирази такої форми називаються лямбдаабстракціями.     Символ х після λ називається зв'язаною змінною абстракції і відповідає поняттю формального параметра в традиційній процедурі або функції. Вираз справа від крапки називається тілом абстракції, і подібно коду традиційної процедури або функції, воно описує, що потрібно зробити з параметром, який надійшов на вхід функції.      Тіло абстракції може бути будь-яким допустимим лямбда-виразом, і тому воно також може містити іншу абстракцію, наприклад:λx. λy. * (+ x y ) 2      Це вираз читається як «функція від х, яка повертає функцію від у, яка повертає (х + у ) * 2 . В мові Haskell дана функція має вигляд:\x -> \y -> (x+y)*2      До функцій в лямбда-нотації застосуємо каррінг (метод обчислення функції від багатьох аргументів шляхом перетворенням її в послідовність функцій одного аргумента), тому всі вони мають тільки один аргумент.     Тому всі абстракції включають тільки один символ λ і єдину зв'язану змінну.     Строго кажучи, це означає, що застосування функцій повинні міститися в дужках, наприклад:(... ((( λх1. λх2. .... λхn.Е )х1)х2)... xn)      Однак існує угода, згідно якої функція застосовується завжди до найлівішого аргументу, і тому дужки навколо кожного вкладення можна опустити без зміни сенсу виразу : ( λх1. λх2. .... λхn.Е ) х1 х2. . . хn  Обчислення лямбда-виразів      Для обчислень лямбда-виразів необхідні правила виведення. Найпростіший тип лямбда-виразу – це константа.      Константи є самовизначеними, тобто їх неможливо перетворити в простіші вирази. Наприклад, обчислення цілої константи 5 дає ту ж саму константу 5.       δ – правило: застосування константної функції може бути перетворено при наявності достатньої кількості аргументів з використанням вбудованих правил. Розглянемо приклад. Нехай є константний вираз: +1 3      Даний вираз може бути перетворено (тобто застосована δ редукція) з урахуванням вбудованого правила +: +1 3 -> 4 Наведений приклад редукції можна прочитати так: « +1 3 перетворюється в 4 »       У загальному випадку аргументи функції можуть не бути в потрібній формі, і тому виконати редукцію неможливо, наприклад: * (+ 1 2) (– 4 1)      Щоб перетворити цей вираз, необхідно спочатку перетворити вираз аргументів функції *. Обчислення його може відбуватися наступним чином : * (+ 1 2) (– 4 1) -> * (+1 2) 3 -> * 3 3 -> 9   	β – правило: описує застосування лямбда-абстракції. Розглянемо наступний вираз: ( λx. + x x ) 2      Ситуація аналогічна виклику процедури або функції мови високого рівня з фактичним параметром, що заміщує її формальний параметр. В лямбда-численні така заміна є текстовою, і ми таким чином фізично замінюємо всі входження зв'язаної змінної х в тілі застосованої лямбдаабстракції на вираз аргументу 2, отримуючи в результаті змінену форму тіла. Отже: ( λx. + x x ) 2 -> + 2 2 (це і є β-редукція).   Процес називається редукцією в тому сенсі, що в даному випадку спрощується вираз, з нього прибираються символ λ, зв'язана змінна і вираз аргументу. В підсумку виходить змінена форма тіла лямбда-абстракції. Редукція абстракції, застосованої до деякого аргументу, може дати в результаті іншу абстракцію, і в цьому випадку процес може бути продовжений. Наприклад, в наступному виразі (( λх. λу . + x у ) 7) 8 редукція починається з підстановки числа 7 замість х в тіло самої зовнішньої абстракції (тобто λу. + х у), при цьому виходить ( λу. + 7 у ) 8 і закінчується застосуванням отриманої абстракції до виразу аргументу 8, при цьому отримуємо + 7 8 Останній вираз перетворюється в 15 за допомогою δ-правила.       Вираз, до якого можна застосувати редукцію, називається редексом, і тому можна зробити висновок, що процес редукції лямбда-виразу складається з множини редукцій, що застосовуються до редексу до тих пір, поки вираз містить хоча б один редекс.      Термін δ-редекс відповідає виразу, який може бути спрощено за допомогою δ-правила, а β-редексом називається вираз, який можна спростити за допомогою β-редукціі. α – правило: заміна одного імені змінної на інше.  Розглянемо приклад: ( λх. ( λх.х ) (+ 1 х )) 1 Тут х в тілі внутрішньої абстракції ( λх.х ) й х у виразі аргументу (+ 1 x ) – це різні змінні, що мають однакове ім'я.      Якщо застосувати цей вираз до аргументу (наприклад, 1), то наступне виконання β-редукції буде помилкою: ( λх. ( λх.х ) (+1 х )) 1 -> ( λх.1) (+1 +1) -> 1 Таким чином, тут необхідне α-перетворення: ( λх. ( λх.х ) (+1 х )) 1 -> ( λх. ( λy.y ) (+1 х )) 1 -> ( λy.y ) (+1 1 ) -> ( λy.y ) 2 -> 2  Розглянемо складніший приклад: ( λf.λx. f 4 х ) ( λу.λх. + x у ) 3 - > ( λf.λz. f 4 z ) ( λу.λх. + x у ) 3 -> ( λf.λz. f 4 z ) ( λу.λх. + x у ) 3 -> ( λz. ( λу.λ х. + x у ) 4 z ) 3 -> ( λу.λх. + x у ) 4 3 -> ( λх. + x 4 ) 3 -> + 3 4 -> 7 Важливо зауважити, що на кроці 3 був вибір між двома редексами, і для перетворення довільно був взятий зовнішній редекс. Однак можна було б застосувати β-редукцію і до внутрішнього редексу, що призвело б до наступного ланцюжку перетворень: ( λf.λx. f 4 х ) ( λу.λх. + х у ) 3 - > ( λf.λz. f 4 z ) ( λу.λх. + х у ) 3-> ( λf.λz. f 4 z ) ( λу.λх. + х у ) 3-> ( λz. ( λу.λх. + х у ) 4 z ) 3-> ( λz. ( λх. + х 4) z ) 3-> ( λх. + х 4 ) 3-> + 3 4 -> 7η-правило: два висловлення (λx. Ex) і E еквівалентні за умови, що x не є вільною змінною в E, тому( λx. Ex ) A -> E A для будь-якого виразу A . Це називається функціональною екстенсивністю. Таким чином, η-перетворення записується у вигляді( λx. Ex ) - > E 3.2 Нормальні форми, редукції та механізми викликуПорядок редукції і нормальні форми      Кажуть, що лямбда-вираз знаходиться в нормальній формі, якщо до нього не можна застосувати правило редукції. Іншими словами, лямбда-вираз знаходиться в нормальній формі, якщо він не містить редексів.      Нормальна форма відповідає поняттю завершення обчислень в традиційному програмуванні. Звідси випливає наступна схема обчислень:while існує хоча б один редекс do перетворити один з редексів end {Вираз тепер в нормальної формі}      Проблема, пов'язана з такою схемою, полягає в тому, що у виразі може бути кілька редексів і незрозуміло, який з них вибрати для перетворення. Розглянемо приклад : ( λx.λy.y ) (( λz.z z ) ( λz.z z )) В цьому виразі два редекси: ( λz.z z ) ( λz.z z )   ( λх.λу.y ) (( λz.z z ) ( λz.z z )) Вибравши перший з них, отримаємо ланцюжок редукцій, який ніколи не закінчиться: ( λz.z z ) ( λz.z z ) -> ( λz.z z ) ( λz.z z ) -> ( λz.z z ) ( λz.z z ) і т.д. Вибравши другий, отримаємо редукцію, яка закінчується за один крок: ( λx.λy.y ) (( λz.z z ) ( λz.z z )) -> λу.у   Це призводить до необхідності розгляду порядку редукції, що визначає в разі виникнення кількох редексів, який з них вибрати для перетворення.      Найлівішим редексом називається редекс, символ λ якого (або ідентифікатор примітивної функції у разі δ-редекса) розташований у λ-виразі лівіше всіх інших редексів. (Аналогічно визначається найправіший редекс).      Самим зовнішнім редексом називається редекс, який не міститься усередині ніякого іншого вкладеного редекса.      Самим внутрішнім редексом називається редекс, що не містить інших редексів.      В контексті функціональних мов і λ-числення існують два важливих порядки редукцій:      Аплікативний порядок редукцій (АПР), який передбачає спочатку перетворювати найлівіший з самих внутрішніх редексів.      Нормальний порядок редукцій (НПР), який передбачає спочатку перетворювати найлівіший з самих зовнішніх редексів. Тоді з попереднього прикладу видно, що найлівішим з самих внутрішніх редексів є ( λz.z z ) ( λz.z z ) а найлівішим з самих зовнішніх є ( λx.λy.y ) (( λz.z z ) ( λz.z z ))      Тоді при аплікативному порядку редукцій першим буде обчислюватися редекс ((λz.z z)(λz.z z)) і обчислення ніколи не закінчиться, тоді як при нормальному порядку редукцій обчислення λ-виразу закінчиться за один крок.       НПР дозволяє ефективно відкладати обчислення будь-яких редексів всередині виразу аргументу до тих пір, поки це можливо, в розрахунку на те, що таке обчислення може виявитися непотрібним. Стратегія вибору найлівішого із самих зовнішніх редексів передбачає виконання підстановки для х в λy.y до будь-якого перетворення виразу аргументу. В результаті за один крок виходить нормальна форма λy.y .      АПР, з іншого боку, обчислює вираз аргументу в першу чергу, що в даному випадку призводить до зациклення.      Таким чином, НПР і АПР відповідають лінивому і енергійному обчисленню.   	 Фундаментальні теореми лямбда числення.      Теорема Чорча-Россера (наслідок). Якщо вираз Е може бути приведено двома різними способами до двох нормальних форм, то ці нормальні форми є алфавітно-еквівалентними. Теорема стандартизації. Якщо вираз Е має нормальну форму, то редукція найлівішого із самих зовнішніх редексів на кожному етапі обчислення Е гарантує досягнення цієї нормальної форми (з точністю до алфавітної еквівалентності).      Ромбічна властивість відношення редукції -> полягає в тому, що якщо вираз Е може редуцією бути приведений до двох виразів E1 і Е2, то існує вираз N , який можна отримати (повторно застосовуючи ->) як з E1, так і з Е2.       Символ ->* позначає довільне число редукцій. Тобто ->* є рефлексивно-транзитивним замиканням відношення ->.   β - редукція і проблема конфлікту імен      Проблему конфлікту імен можна проілюструвати на наступному прикладі: λx. (( λy.λx. + x y ) x ) Цей вираз містить єдиний β-редекс. Якщо спробувати обчислити цей редекс, то отримаємо λx. ( λx. + x x ) що, очевидно, є помилкою.      Проблема полягає в тому, що в цьому прикладі вираз аргументу містить вільну змінну, що має однакове ім'я з однією із зв'язаних змінних в тілі абстракції. Щоб безпечно виконувати β-редукцію, необхідно спочатку модифікувати абстракцію так, щоб всі імена зв'язаних змінних стали унікальними по відношенню до вільних змінних у виразі аргументу, тобто виконати α-перетворення. Але α-перетворення є досить ресурсномістким.      Виявляється, що проблему можна вирішити без α-перетворення, визначивши обмежену нормальну форму – так звану слабку заголовну нормальну форму.       Вираз Е знаходиться в слабкій заголовній нормальній формі (СЗНФ), якщо: 1) Е є константою, 2) Е є виразом виду λх.Е' для будь-якого Е', 3) Е має форму РЕ1Е2 ... Еn для будь-якої константної функції Р арності k > n.  Третє правило стверджує, що будь-яка частково застосована константна функція також є СЗНФ. Наприклад, вираз * 3 можна переписати, використовуючи η-редукцію: λx. * 3 x який є СЗНФ.       Перевага приведення виразів до СЗНФ замість повної нормальної форми полягає в тому, що немає необхідності застосовувати β-редукцію за присутності вільних змінних. Використовуючи попередній приклад λx. (( λy.λx. + x y ) x ) бачимо, що вираз знаходиться в СЗНФ. Тобто даний редекс обчислювати не треба .      Тільки коли вираз застосовується до аргументу, обчислення має місце, і це обчислення почнеться з видалення найлівішої зв'язаної змінної x відповідно до правил редукції нормального порядку, наприклад: ( λх. (( λу.λх. + у х ) х )) 4 -> ( λу.λх. + у х ) 4 -> λх. +4 х   Варто зауважити, що в проміжку між нормальною формою і СЗНФ розташована так звана заголовна нормальна форма (ЗНФ). Кажуть, що вираз Е знаходиться в ЗНФ , якщо: 1) Е є константою, 2) Е є виразом виду  λх1. λх2 ... λхn.Е', де Е не є редексом, 3) Е має форму РЕ1Е2 ... Еn для будь-якої константної функції Р арності k > n.  Зазвичай, приведення до ЗНФ не практикується, тому що в цьому випадку не вдається уникнути конфлікту імен.                        Ефект поділу Розглянемо приклад: ( λх. + х х ) Е Застосувавши до нього правило β-редукціі, отримаємо + Е Е      Щоб перетворити цей вираз, необхідно спочатку перетворити аргументи функції +, а це означає, що над виразом Е двічі має бути виконана редукція. Це обчислення дуже неефективне. Один спосіб, який гарантує, що аргумент ніколи не буде обчислюватися більш одного разу, полягає в обчисленні його перед виконанням β-редукції. Це відповідає аплікативному порядку редукції. Замість підстановки аргументу у вихідному вигляді, виконується підстановка значення аргументу, тому повторні входження зв'язаної змінної не призводять до повторної редукції аргументу.       Якщо необхідно реалізувати нормальний порядок редукції, то певним чином треба зробити так, щоб перший обчислений (приведений до СЗНФ) вираз аргументу «розділився» між усіма іншими виразами цього аргументу тобто замінив кожне з них своїм значенням. Це означає, що необхідно відійти від моделі редукції, запропонованої в λ-численні, де обчислення виразів записується в чисто текстовій формі.       Це означає, що можна записувати проміжні вирази, що формують послідовність редукції, за допомогою набору символів на звичайному аркуші паперу (такий процес іноді називають редукцією рядків).      Якщо необхідно вивчити ефект поділу, то слід встановити факт, що два входження одного і того ж ідентифікатора відносяться до одного і того ж висловлення.       Один з способів зробити це полягає в поданні виразів в вигляді графів. Це призводить до ідеї редукції графів. У такому випадку варто дотримуватися наступної домовленості. Маючи вираз вигляду ( λx. ... х ... х . ..) Е результат його β-редукції будемо записувати у вигляді ... х ... х ..., де х є Е       Зв'язок між іменами змінних і їх значеннями зазвичай називається контекстом. Сенс такого підходу в тому, що коли х (тобто Е) обчислюється вперше, скорочена форма Е замінює не тільки х у виразі, але й E в контексті цього виразу. Розглянемо приклад : ( λх. + х х ) (+ 1 2) - > + х х де х є (+1 2) -> + 3 х де х є 3 -> + 3 3 -> 6   	 Схеми редукції і механізми виклику     В функціональних мовах програмування виклик по значенню відомий як енергійне обчислення, яке в λ-численні ми можемо визначити наступним чином.Енергійне обчислення = АПР, що приводить вираз до СЗНФ. В якості альтернативи АПР можна використовувати НПР.     В λ-численні, де відсутнє поняття поділу, така підстановка є чисто текстовою. Тому вона відповідає поняттю виклику по текстовій заміні. Очевидно, при цьому може виникнути конфлікт імен та необхідність повторного обчислення виразів аргументів.       Якщо реалізується нормальний порядок редукцій та підтримується поділ, тоді механізм редукції відповідає виклику по необхідності. Таким чином, виклик по необхідності можемо охарактеризувати як нормальний порядок редукції, що приводить вираз до СЗНФ разом з поділом виразів аргументів. Отже, ліниве обчислення значення λ-виразу можна охарактеризувати наступним чином.   Ліниве обчислення = НПР , що приводить вираз до СЗНФ + поділ + ліниві конструктори Або еквівалентно.Ліниве обчислення = виклик по необхідності + ліниві конструктори . 3.3 Рекурсивні функції Рекурсивні вирази     Розглянемо проблему рекурсивних функцій в λ-численні, де функції не мають імен. Очевидно, що для подання рекурсії необхідний метод, який дозволяє функції викликати себе не по імені, а якимось іншим чином.     Для представлення рекурсії зручно використовувати погляд на рекурсію, при якому рекурсивну функцію можна представити як функцію, що приймає саму себе в якості аргументу. У цьому випадку функція може виявитися зв'язаною з однією з власних змінних та буде, таким чином, містити в своєму тілі посилання на саму себе.   Розглянемо приклад . Нехай є рекурсивна функція: sum :: Int -> Int sum n = if n == 0 then 0 else n + sum (n-1) Цей вираз може бути представлено в вигляді λ-абстракції, що має додатковий параметр, який при застосуванні цієї абстракції зв'язується з самою функцією: SUM = λs. λn.COND ( = n 0) 0 (+ n (s (– n 1))) Тепер необхідно зв'язати змінну s із значенням функції SUM. Це можна зробити, використавши спеціальну функцію що називається Yкомбінатором, яка задовольняє наступне рівняння: Yf = f( Y f )  Тут Y також відомий як комбінатор нерухомої точки.      «Нерухома точка» функції f – це вираз, який не змінюється при застосуванні до нього функції f. Функція може мати кілька нерухомих точок; наприклад, функція тотожності λх.х має їх нескінченну кількість. Вираз Yf дає найменшу нерухому точку функції f . Розглянемо застосування Y до функції SUM: Y SUM = Y ( λs. λn.COND (= n 0) 0 (+ n (s (– n 1)))) -> ( λs. λn.COND (= n 0) 0 (+ n (s (– n 1)))) ( Y SUM) -> ( λn.COND (= n 0) 0 ( + n ( ( Y SUM) (– n 1)))) Розписавши внутрішній вираз Y SUM маємо:  -> ( λn.COND (= n 0) 0 (+ n (( λn.COND (= n 0) 0 (+ n ((Y SUM) (– n 1 )))) (– n 1))))  Бачимо, що вираз поводить себе так само, як вихідне рекурсивне визначення sum. Внутрішнє входження Y SUM конструює копію вихідної функції SUM і розміщує саме себе (тобто Y SUM ) замість s в тіло копії. Таким чином, функція sum може бути записана в λ–численні в вигляді Y SUM, тобто       	 	 	 Y ( λs. λn.COND (= n 0) 0 (+ n ( s (– n 1)))) У загальному випадку рекурсивна функція f з тілом, що задається виразом Е, записується в λ-численні в вигляді    	 	 	 	 	 	 Y ( λf.E )   Взаємна рекурсія      У загальному випадку можна визначити набір взаємно рекурсивних функцій наступним чином : f1 (...) = E1 f2 (...) = E2 ................... fn (...) = En де Ei може посилатися на будь-яку (або на всі відразу) функцію fj (1 ≤ i, j ≤ n). Для реалізації даних визначень використовуються кортежі. Ідея полягає в тому, щоб упакувати набір з n взаємно рекурсивних функцій в n-кортеж і потім транслювати посилання на fi в індекс i-гo елемента такого кортежу.      Для реалізації цієї ідеї необхідно використовувати константні функції  TUPLE-n та INDEX: TUPLE-n Е1 Е2 ... Еn  будує кортеж, що складається з виразів Е1, Е2, ..., Еn, який іноді записують в вигляді < E1, Е2, ..., En >. INDEX k <E1, Е2, ..., En> = Ek (1 < k < n).       Функції f1, f2, ..., fn можна переписати в вигляді λ-виразів L1, ..., Ln, залишаючи кожне входження будь-якої з функцій f1 в тілах функцій f1, ..., fn без змін. Після цього можна з'єднати ці вирази в n-кортеж Т, використовуючи функцію TUPLE-n:  T = TUPLE-n L1 L2 ... Ln      Елементи Т можна модифікувати, замінюючи всі посилання на функцію fi в Li (1 ≤ i , j ≤ n) на виклики функції INDEX наступним чином:fi -> INDEX i TМодифіковані вирази Li будемо позначати Li'. Тоді Т має виглядТ = TUPLE-n L1' L2' ... Ln' Це визначення рекурсивне, оскільки кожне Li' може саме містити посилання на Т. Для завершення визначення, потрібно до виразу Т застосувати Yкомбінатор:Т = Y ( λT.TUPLE-n L1' L2' ... Ln' ) Даний вираз є поданням набору функцій f1 ... fn.  Розглянемо приклад. Нехай є дві взаємно рекурсивні функції :f :: Int-> Int g :: Int -> Int f n = if n == 0 then 0 else g n g n = n + f (n-1) Вони можуть бути представлені наступним λ-виразом:Y ( λT.TUPLE-2 ( λn.COND (= n 0) 0 ((INDEX 2 Т ) n )) ( λn. + N ((INDEX 1 Т ) (– n 1)))) Визначення Y     Розглянемо визначення Y-комбінатора в термінах λ-виразу. Вираз, що представляє Y, має вигляд :λh.( λx.h( x x )) ( λx. H( x x )) Для того, щоб переконатися в цьому, розглянемо вираз :Yf = ( λh.( λx.h( x x )) ( λx.h( x x ))) f -> ( λx.f( x x )) ( λx.f( x x )) -> f(( λx.f( x x )) ( λx.f( x x ))) = f( Yf ) 3.4 Чисте λ-числення     У чистому λ-численні відсутня поняття типізованих констант. Іншими словами, в чистому λ-численні відсутня δ-редукція.                   Булеві константи і булеві операції Розглянемо вираз: if P then Q else R (або COND PQR) Тут умовний оператор (COND) – вбудована функція, яка вибирає Q або R в залежності від значення предиката Р. Іншими словами, предикат умовного оператора можна розглядати як функцію, яка сама вибирає один з виразів Q або R. Вираз COND PQR в цьому випадку транслюється в PQR з правилами перетворенняTRUE х у -> х FALSE x y -> y Цей підхід дає основу для подання булевих констант і операцій засобами чистого λ -числення. Умовний оператор COND може бути представлений у вигляді:     COND = λp. λq. λr. pqr TRUE і FALSE представляються у вигляді:TRUE = λx. λy. x FALSE = λx. λy. y Розглянемо приклад :COND TRUE А В = ( λp. λq. λr. p q r ) ( λх. λу.х ) А В -> ( λq. λr. ( λx. λy. x ) q r ) А В -> ( λr. ( λх. λу.х ) А r ) В -> ( λх. λу.х ) А В -> ( λу.А ) В -> А   	Функції AND і OR мають вигляд : AND = λx. λy. x у FALSE OR = λx. λy. (x TRUE) y Вірність такого представлення може бути доведена отриманням відповідних таблиць істинності. Наприклад: TRUE AND FALSE = and true false = ( λх. λу. х у ( λх. λу.у )) ( λх. λу.х ) ( λх. λу.y ) -> ( λу. ( λх. λу.х ) у ( λх. λу.у )) ( λх. λу.у ) -> ( λх. λу.х ) ( λх. λу.у ) ( λх. λу.у ) -> ( λу. ( λх. λу.у )) ( λх. λу.у ) -> ( λх. λу.у ) = FALSE  Списки в чистому λ-численні 	Зазвичай, 	списки 	будуються 	за 	допомогою 	двох 	функцій-конструкторів, одна з яких позначає порожній список (NIL), а інша будує новий список з елементами старого списку (CONS). Конструктор CONS в λчисленні має вигляд: CONS = λh. λt. λs.s h t Тут змінні h, t, s відповідають голові списку, хвосту списку і функціїселектору.      Селектори – це такі функції, які повертають або перший, або другий аргумент функції-конструктора. Тому вони можуть бути представлені у вигляді наступних λ-виразів : λh. λt.h і λh.λt.t що в точності відповідає визначенням TRUE і FALSE .       Тоді функції для виділення головного і хвостового елементів списку L (тобто HD і TL відповідно) можуть бути визначені наступним чином:HD = λL.L TRUE TL = λL.L FALSE Розглянемо приклад :HD ( CONS а b ) = ( λs.s TRUE) (( λh. λt. λs.s h t) a b) -> (( λh. λt. λs.s h t) a b) TRUE -> ( λs.s a b) TRUE -> TRUE ab = ( λh. λt. h) a b -> ( λt. a ) b -> a      Функція IE, яка повертає TRUE у разі якщо список порожній, має вигляд:IE = λs.s ( λh. λt. FALSE ) Порожній список NIL на мові λ-числення має вигляд:NIL = λx. TRUE Розглянемо приклад :IE (TL (CONS 1 NIL)) = ( λs.s ( λh. λt. FALSE)) (TL (CONS 1 NIL)) -> (TL (CONS 1 NIL)) ( λh. λt. FALSE) = (( λs.s FALSE) (CONS 1 NIL)) ( λh. λt. FALSE) -> ((CONS 1 NIL) FALSE) ( λh. λt. FALSE) -> ((( λh. λt. λs.s h t) 1 NIL) FALSE) ( λh. λt. FALSE) -> ((( λt. λs.s 1 t) NIL) FALSE) ( λh. λt . FALSE) -> (( λs.s 1 NIL) FALSE) ( λh. λt . FALSE) -> (FALSE 1 NIL) ( λh. λt. FALSE) = (( λx. λy. y) 1 NlL) ( λh. λt. FALSE) -> (( λу.у ) NIL) ( λh. λt. F ALSE ) -> NIL ( λh. λt. FALSE) -> ( λx. TRUE) ( λh. λt. FALSE ) -> TRUE Натуральні числа в чистому λ-численні      Натуральне число n можна розглядати як n-елементний список об'єктів, що мають довільні значення. Виходячи з цього, можна визначити натуральні числа.     Число 0 в цьому випадку відповідає порожньому списку (NIL). Функція SUCC повертає наступний за n-тим елемент натурального ряду. Отже, вона додає одиницю до даного числа n та повинна тільки розширити на один елемент список з n елементів. Тоді SUCC буде мати вигляд:SUCC = λn.CONS "any" n де "any" – це будь-який λ-вираз.λ-числення де Брейна      В λ-численні цілком можливо записати два вирази, які є семантично ідентичними, але синтаксично відрізняються один від одного через різні імена змінних.     Основна ідея канонічного λ-числення де Брейна полягає в тому, щоб видалити з λ-виразу всі імена змінних, замінивши їх на цілі числа. λ-вираз в такому випадку складається з цілих чисел, що представляють порядкові номери символів λ, що пов'язують змінні, замінені цими цілими числами, і з самих символів λ. При цьому семантично еквівалентні λ–виразу та є також синтаксично еквівалентними.     Ціле число, яке заміняє змінну, можна розглядати як «зсув» або «глибину вкладеності» символу λ, що вводить цю змінну, після якого в цьому випадку немає ніякої необхідності вказувати ім'я змінної.     В якості прикладу наведемо представлення в λ-численні де Брейна функції (SUCC):λ. + L0 1 Більш складний λ-виразλх. λу. λf. f( λx'.x ) ( + х у ) має наступне канонічне представлення:λ. λ. λ. L2 ( λ.L0) (+ L0 L1) Оскільки в канонічному λ-численні немає імен змінних, там немає еквівалента правилам α-перетворення виразів.3.5 Типізоване λ-численняСистема виведення типів і перевірка типів      Наступний розгляд виведення та перевірки типів можна вважати неформальним вступом до типізованого лямбда-числення.  Перевірка типів важлива з двох причин.     По-перше, вона дозволяє виявити багато логічних помилок програми ще на етапі компіляції. Більшість з них є результатом невідповідності типів виразів, так що запускати програму для виявлення цих помилок просто немає необхідності.     По-друге, програма на етапі виконання працює більш ефективно, так як будь-яке згадування про типи даних може повністю бути відсутнім в коді, що створюється компілятором.Неформальна перевірка типів      Тип – це або змінна типу або застосування оператора типу до певного числа аргументів типу.      Базові типи, такі як int (цілий тип) і bool (логічний тип), є операторами типу без аргументів, a [] ( для зручності будемо писати list ) – це оператор типу з одним аргументом. Також будемо використовувати бінарні інфіксні оператори -> (оператор типу функції ) та X (оператор типу декартового добутку).      Типи, що містять принаймні одну змінну, є поліморфними (політипами), а типи, які не містять змінних типу, є мономорфними (монотипи).       Таким чином, базові типи є монотипами, так само як і типи багатьох примітивних функцій, наприклад succ :: int -> int та is–zero :: int -> bool. Однак не всі примітивні функції є мономорфними, наприклад hd [a] -> а є поліморфною, оскільки її визначення типу містить змінну типу а.      Можна визначати довільно складні вирази типу, наприклад вираз типу для функції map може бути записано таким чином: ( a -> b ) -> [a] -> [b] або ( a -> b ) X list a-> list b      При перевірці типу виразу необхідно знайти найзагальніший тип, який він може мати. Тобто типи які одержані при присвоєнні змінним типу конкретних значень, є частинними випадками цього найбільш загального типу.      Іншими словами, необхідно сконструювати систему виведення типів, яка б змогла визначити найзагальніший тип, або прийти до протиріччя, яке означає, що цей вираз не має найбільш загального типу.      Основну ідею виведення типу можна зрозуміти, розглядаючи застосування функції f до виразу E. Якщо відомо, що E має тип σ, то можна зробити висновок, що тип f – це σ -> ρ, де ρ – тип, який повинен бути отриманий.      Якщо включити в розгляд кваліфіковані вирази, отримаємо більш складний випадок, оскільки тип присвоюється ідентифікатору двічі (в кваліфікаторі та в результаті), і тому необхідно ототожнити такі типи, щоб отримати найзагальніший. Розглянемо приклад . Нехай є вираз вигляду:  let f x = x in f 3 Щоб мало місце узгодження між типами його підвиразів, потрібно обчислити рівняння: σ3 = Int 	   (базовий тип )                         	 	 	 	 (1) σf = Int -> ρ1 ( f 3 – це застосування функції)      	 	 	 (2) σx = ρ2           (тип x невідомий)  	 	 	 	 	 	 (3) σf = ρ2-> ρ3  ( f x – це застосування функції)      	 	  	 (4) ρ3 = ρ2 	 (дві частини рівності повинні мати однаковий тип)  (5)    З цих рівнянь можна бачити, що ρ2 = Int , ρ1 = ρ3 (з рівнянь (2) і (4)), ρ3 = ρ2 (рівняння (5)), що в результаті дає ρ1 = ρ2 = ρ3 = Int , і типом виразу f3 є ρ1 = Int , як і очікувалося . Той факт , що система рівнянь має розв’язок, говорить про коректність виразу Е з точки зору його типу. 	Аналогічні 	міркування 	справедливі 	для 	поліморфних 	виразів. Розглянемо в якості прикладу функцію map: map f [] = [] map f (x:xs) = f x: map f xs Оскільки примітивні функції обробки списків є поліморфними, призначимо нові невідомі типи η1, η2, ... змінним типу цих функцій. Тоді маємо наступні рівняння: σ ([ ]) = list η1 σ (:) = (η3 X list η3 ) -> list η3 Рівняння що гарантують відповідність типів кожного підвиразу в визначенні map мають вигляд: σ(map) = σf X σm -> ρ1  Для деякої невідомої змінної типу ρ1        (1) σf = ρ2-> ρ3                                                           (2) σ(mар) = σf X ρ2-> ρ3                                           (3) σ(:) = ρ3 X ρ4 -> ρ5 	 	 	 	 	 	 	 	     	(4)        Необхідне також рівняння, яке потребує, щоб обидві частини рівності у визначенні mар мали однаковий тип:ρ1 = σ([ ]) = ρ5  	 	 	 	 	 	 	 	 	 	(5)       Розв’язок даної системи рівнянь буде мати вигляд:σm = ρ2 ρ1 = ρ3 ρ3 = list η3 ρ4 = list η3 ρ5 = list η3 Звідси отримуємо: σm = ρ2 ρ1 = ρ3 = list η3 ρ5 = ρ4 = list η3 Типізоване лямбда-числення     Типи є зручним засобом визначення різних різновидів даних, таких як логічні і цілочисельні значення або функції. У типізованому лямбда-численні лямбда-терму може бути присвоєно тип. Для чого необхідне типізоване лямбда-числення:1. Подолання парадоксу Рассела (парадокс цирульника). Джерелом протиріч служить незвичайна циклічна природа прийому, що використовується, – застосування функції до самої себе.2. Застосування типізації в мовах програмування. Одна з причин введення типів в мовах програмування – це підвищення ефективності породжуваного компілятором коду.3. Обмежена статична перевірка коректності програм.     Розглянемо введення типу в лямбда-численні. Якщо M – терм і тип α присвоєно M, то пишуть:M : α      Наприклад, для тотожної функції можна написати I : α -> α. Тобто тотожній функції присвоєно тип α -> α. Якщо тип аргументу Х тотожної функції α, то її значення теж має тип α. У загальному випадку α -> β є типом функції з α в β. Існує дві системи типізації: • по Чорчу,                    • по Каррі.                           В типізації по Чорчу явно вказується тип. Кожен терм отримує єдиний тип, тобто в ході побудови термів для кожного з розглянутих раніше нетипізованих термів вказується тип. Типи констант є визначеними, але типи змінних можуть бути довільними.  Точні правила побудови типізованих термів мають вигляд:  _________ ν:σ  Константа с має тип σ с: σ Також s: σ -> τ t: σ s t: τ  ν: σ      t: τ λν.t : σ -> τ      В типізації Каррі структура термів відповідає нетипізованому випадку, при цьому терм може як мати тип (причому не один), так і не мати його. Наприклад, тотожній функції λx.x може бути цілком обґрунтовано присвоєно довільний тип вигляду σ -> σ.      В мові Haskell існують два взаємопов'язаних аргументи на користь даного підходу до типізації: по-перше, він дозволяє зручніше висловити властивий Haskell поліморфізм; по-друге, він добре узгоджується з практикою програмування на цій мові, коли не завжди потрібно ставити типи явно.      В той же час, деякі формальні аспекти призначення типів по Каррі виявляються досить складними.      Відношення типізації не може бути задане відриваючись від певного контексту, який є скінченною множиною тверджень щодо типів змінних. Нехай Г ├ t : σ Тобто, твердженню в контексті Γ терма t може бути призначений тип σ. (Якщо це твердження справедливе при порожньому контексті, то вираз скорочується до t: σ.) Елементи множини Γ мають вигляд ν : σ , отже вони самі по собі є твердженнями щодо типів окремих змінних, зазвичай тих, які входять в терм t. Правила типізації в системі Каррі мають вигляд: ν:σ ∈ Γ Г ├ ν:σ  Константа с має тип σ с:σ  Г ├ s:σ -> Г ├  t:σ Г t s: τ  Г ∪ {ν:σ}├ t:τ Г ├ λν.t : σ -> τ Як приклад, розглянемо процедуру виведення типу тотожної функції. Згідно правилу типізації змінних, маємо: { ν : σ } ├ x : σ, звідки, застосувавши останє правило, отримуємо ├ λx.x : σ -> σ Цей вираз можна скоротити до  λx. x: σ -> σ      Звідси бачимо важливість контекстів в типізації по Каррі, так само, як і їх необов'язковість в типізації по Чорчу. Опускаючи контекст, можна вивести x: τ для довільного типу τ, після чого, відповідно до останнього правила, отримуємо λx.x: σ -> τ,  звідки видно відмінність з інтуїтивним трактуванням тотожної функції.      Ця проблема не виникає в процесі типізації по Чорчу, оскільки в такому випадку або обидві змінні мають тип σ, звідки отримуємо λx.x: σ -> σ, або ці змінні є різними (оскільки різні їх типи, які вважаються частиною терма). В останньому випадку тип виразу буде дорівнювати λx: σ.(х: τ): σ -> τ.   Збереження типу      Схожість структури термів типізованого і нетипізованого лямбдачислення породжує природне бажання застосувати в типізованому випадку апарат формальних перетворень, розроблений для нетипізованого лямбдачислення. Однак, в такому випадку буде потрібно довести, що тип виразу в ході перетворень не змінюється (ця властивість називається збереженням типу).       Розглянемо лему, яка говорить про те, що додавання нових елементів в контекст не впливає на типізацію. Лема 1. Якщо Γ├ t : σ і Γ ⊆ Δ , то справедливо Δ ├ t: σ.      Наступна лема говорить про те, що елементи контексту, що представляють змінні, які не є вільними в заданому термі, можуть ігноруватися. Лема 2. Якщо Γ ├ t: σ , то справедливо також   Γt ├ t: σ , де Γt містить виключно вільні змінні терма t ( Γ t = {x: α | x: α ∈ Γ та x ∈ FV (t)}).      І нарешті, теорема про збереження типу (в даному випадку для ηредукції; аналогічну теорему можна довести і для β-редукції). Теорема. Якщо Γ ├ t: σ та t η -> t ', то з цього випливає, що Γ ├ t ' : σ. Зібравши разом результати аналогічних доведень для інших перетворень, отримуємо, що якщо Γ ├ t: σ та t -> t ', то виконується також Γ ├ t ' : σ.      Важливість цього висновку в тому, що якщо би правила обчислень, що застосовуються в ході виконання програми, могли змінювати типи виразів, це суперечило б основам статичної типізації.   Поліморфізм.      Типізація по Каррі надає різновид поліморфізму, що дозволяє призначити заданому терму різні типи. Тут слід розрізняти схожі поняття поліморфізму і перевантаження.      Обидва вони мають на увазі, що вираз може мати багато типів. Однак, в разі поліморфізму, всі ці типи структурно пов'язані один з одним, що допускає будь-які з них, що задовольняють заданому зразку. Наприклад, тотожній функції можна призначити тип σ -> σ, або τ -> τ, або навіть          (σ -> τ) →  (σ -> τ), але всі вони мають однакову структуру.      З іншого боку, суть перевантаження в тому, що задана функція може мати різні типи, структура яких може різнитися, або ж допустима лише обмежена множина типів. Наприклад, функції «+» може бути дозволено мати тип int -> int -> int або float -> float -> float, але не bool -> bool -> bool.      Ще одним близьким поняттям є підтипи, які є більш строгою формою перевантаження. Введення підтипів дозволяє трактувати деякий тип як підмножину іншого.  Проблеми let-поліморфізму      Розглянута вище система типів накладає деякі небажані обмеження на поліморфізм. Зокрема, наступний вираз є абсолютно коректним : if ( λx. x) true then ( λx. x) 1 else 0      Доведемо, що це вираз може бути типізованим. Припустимо, що константам можна призначити типи в порожньому контексті, і що можна двічі застосувати правило типізації комбінацій термів для призначення типу if (зауважуючи, що вираз вигляду if b then t1 else t2 є лише скороченням запису для COND b t1 t2).   	{ x: bool} ├ x: bool             	 	{ x: int } ├ x: int ____________________  ____________    _________________   ________ ├ ( λx. x): bool - > bool     ├ true: bool      ├ ( λx. x): int - > int      ├ 1: int _________________________________________________________________ 	     ├ ( λx. x): true - > bool  	 	         ├ ( λx. x): 1 > int        ├ 0: int __________________________________________________________________ ├   if ( λx. x): true then ( λx. x) 1 else 0: int  Два екземпляри тотожної функції отримують типи bool -> bool та int -> int відповідно. Розглянемо інший вираз: let I = λx. x in if I true then I 1 else 0 За означенням, це лише зручніший спосіб запису для ( λI. if I true then I 1 else 0) ( λx. x)      Отже, тип цього виразу не може бути виведений в межах описаних вище правил. Тобто, є єдиний екземпляр тотожної функції, якому необхідно призначити єдиний тип.      Подібне обмеження на практиці неприйнятно, оскільки функціональне програмування передбачає часте використання let. Якщо правила типізації не будуть змінені, то втрачається багато можливостей поліморфізму. Тому рішенням буде відмова від трактування конструкції let як скороченого запису на користь реалізації її як примітиву мови, після чого до множини правил типізації слід додати нове правило: Г ├ s: σ Г ├ t [s / x]: τ__________________Г ├ let x = s in t: τ      Це правило, яким вводиться поняття let-поліморфізму, демонструє, що з точки зору типізації let-зв'язані змінні трактуються як прості підстановки відповідних виразів замість їх імен.      Додаткова умова Γ ├ s: σ потрібна виключно для того, щоб гарантувати існування коректного типу виразу s, причому точне значення цього типу нас не цікавить.      Мета даного обмеження в тому, щоб уникнути помилкових висновків про існування коректних типів для таких термів, якlet x = λ f. F f in 0      Тепер можна вивести тип проблемного let-виразу, користуючись наведеними вище правилами : ________________{ x: σ } ├ x: σ                  ................______________________________________	├ ( λx. x): σ - > σ  	├   if ( λx. x): true then ( λx. x) 1 else 0: int _____________________________________________________________├ let I = λx. x in if I true then I 1 else 0 Найзагальніший тип      Як було зазначалося, тип деяких виразів (наприклад, λf. F f або λf. (f true, f 1), вивести неможливо. Типізовані вирази зазвичай мають множину типів, хоча деякі з них, наприклад, true має лише один.      Різновид поліморфізму, доступний в мові Haskell, називається параметричним, отже будь-які типи виразів повинні мати структурну подібність. Більше того, для кожного типізованого виразу існує так званий найзагальніший (головний) тип, причому всі можливі типи даного виразу представляють собою екземпляри найзагальнішого типу.      Розглянемо розширення типу, доповнене поняттям змінної типу. Це означає, що типи можуть бути побудовані шляхом застосування конструкторів типів як до типів-констант, так і до змінних.      Будемо використовувати грецькі літери α і β для позначення змінних типу та σ і τ для довільних типів.       За допомогою цієї розширеної нотації можна визначити поняття підстановки типу в інший тип замість змінної типу. Така підстановка в точності відповідає підстановці термів, тому може використовувати ті ж самі позначення (наприклад, ( σ -> bool) [( σ -> τ ) / σ ] = ( σ -> τ ) -> bool).      Однак, формальне визначення підстановки типів простіше, ніж для термів, оскільки не вимагає враховувати зв'язування змінних. Тоді маємо  αi [τ1 /α1,…, τn /αk] = τi   if   αi  ≠ β  for 1≤ i ≤ k β [τ1 /α1,…, τn /αk] = β   if   αi  ≠ β  for 1≤ i ≤ k (σ1,…, σk) con[θ] = (σ1[θ],…, σk[θ]) con     Типи констант трактуються як нуль-арні конструктори типів, тобто () int еквівалентний int. Враховуючи наведене визначення підстановки, можна ввести відношення, що тип σ є загальнішим за тип σ', позначивши його через σ σ'. Пара типів утворює таке відношення тоді і тільки тоді, коли знайдеться множина підстановок θ таке що σ ' = σ θ. Наприклад: α σα -> α  β -> β α -> bool   ( β -> β ) -> bool β -> α  α -> βα -> α  ( β -> β ) -> βЗ урахуванням викладеного, можна сформулювати теорему:Теорема. Кожен типізований терм має головний тип, тобто для довільного t: τ знайдеться тип σ  такий, що t: σ, і для будь-якого типу σ' з t: σ' випливає σσ'.          Відношення  є відношенням квазіпорядку, що є рефлексивним і транзитивним. Головний тип не унікальний, але при цьому всі його можливі форми рівні з точністю до перейменування змінних типів, що входять в них.       У більш точному формулюванні, якщо σ і τ є одночасно головними типами виразу, то справедливо σ ~ τ , тобто є σ   τ  та τ  σ одночасно.      Процедура доведення цієї теореми представляє собою конкретний алгоритм пошуку такого типу. Цей алгоритм відомий як алгоритм Мілнера (чи алгоритм Хіндлі-Мілнера).Сильна нормалізація Розглянемо терми, що не мають нормальної форми, такі як(( λx. xxx ) ( λx. xxx )) − >(( λx. xxx ) ( λx. xxx ) ( λx. xxx ))-> (· · · ) В межах типізованого лямбда-числення подібна ситуація неможлива на підставі теореми про сильну нормалізацію:Теорема (про сильну нормалізацію). Будь-який типізований терм має нормальну форму, а будь-яка можлива послідовність редукції, яка починається з типізованого терма, завершується.      Маємо очевидну перевагу: функціональна програма, яка задовільняє дані типи, може обчислюватися в довільному порядку, при цьому процес редукції завжди скічненний і призводить до єдиної нормальної форми. (Єдність випливає з теореми Чорча-Россера, яка залишається справедливою і для випадку типізованого лямбда-числення.)      Можливість реалізації функцій, що не завершуються, необхідна для забезпечення повноти за Тьюрінгом, інакше неможливо визначити довільні обчислювальні функції, і більше того, навіть не всю множину всюди визначених функцій.      Можна було б знехтувати цим обмеженням, якщо воно дозволяло використовувати всі функції, що мають практичний інтерес. Однак, це не справедливо, оскільки клас функцій, які можна представити в межах типізованого лямбда-числення, виявиться вузьким.      Оскільки всі визначимі функції є всюди визначеними, то неможливо давати довільні рекурсивні визначення.       Виявляється, звичайні комбінатори нерухомої точки не можуть бути типізовані. Очевидно, що тип Y = λf. ( λx. f (xx)) ( λx. f (xx)) не існує, оскільки x застосовується до самої себе, бо пов'язана лямбда-абстракцією.      Для відновлення повноти за Тьюрінгом можна ввести альтернативний спосіб задання довільних рекурсивних функцій, що не порушує типізацію.      Визначимо поліморфний оператор рекурсії, всі можливі типи якого мають вигляд Rec: (( σ -> τ ) -> ( σ -> τ )) -> σ -> τ і додаткове правило редукції, згідно з яким для довільної функції F: ( σ -> τ ) -> ( σ -> τ )  маємо  Rec F -> F (Rec F)      Тоді можна припустити, що рекурсивні визначення вигляду let відображаються на ці оператори рекурсії.  	 3.6 Елементи теорії категорій Визначення 1. Категорія складається з:  • сукупності об'єктів, при цьому якщо Х є об'єктом С, то це записується як X∈C;   • множин морфізмів з X в Y для кожної пари об'єктів X та Y. Такі множини позначаються як homset.     Таким чином, категорію можна уявити як сукупність множин (які, можливо, мають додаткову структуру) та відображень (що зберігають цю структуру). Для цих компонентів категорії виконуються такі правила. • Для довільного об'єкта X існує тотожний морфізм.• Можна робити композицію морфізмів, яка також іноді записується якg ° f.• Тотожний морфізм є одночасно лівою та правою одиницею відноснооперації композиції, тобто f ° 1x = f = 1y ° f.• Операція композиції асоціативна, тобто (hg) f = h (gf) для довільних морфізмів f, g та h.Визначення 2. Морфізм називається ізоморфізмом, якщо у нього є обернений морфізм, тобто існує морфізм такий, що g ° f = 1x  та  f ° g = 1y.      Категорія є найпростішою конструкцією, що дозволяє описувати системи (об'єкти) та процеси (морфізми).      Якщо для двох морфізмів f : X -> Y та g : Y -> Х виконується рівність gf = 1x, то морфізм g є лівим оберненим до f, а f – правим оберненим до g.      Двосторонньо оберненим (або просто оберененим) до морфізму f називається морфізм, який є лівим і правим до f. Лема. Якщо морфізм має правий і лівий обернений, всі вони співпадають, при цьому f – ізоморфізм. Приклади категорій. 1. Категорія множин та функцій. (Класом об'єктів цієї категорії є класусіх множин, і для двох множин X та Y множина hom(X,Y) є множиною всіх функцій з X в Y).2. Категорія топологічних просторів та неперервних відображень.3. Категорія груп та гомоморфізмів.4. Категорія нормованих кілець та неперервних груп.5. Категорія скінченновимірних гільбертових просторів і лінійнихоператорів на них.Визначення 3. Функтор із категорії C в категорію D є відображенням, яке: • відображає кожен об'єкт X∈C в деякий об'єкт F(X)∈D;• відображає кожен морфізм із категорії С в морфізм в категорії D.Функтор має задовольняти наступні умови: • для всіх об'єктів X∈C функтор зберігає тотожні морфізми: F(1x) = 1F(x);• для довільної пари морфізмів з категорії С функтор зберігає композицію: F(gf) = F(g) F(f).     Функтор можна також трактувати як «представлення» категорії С в D. Сенс полягає в тому, що функтор F може відображати об'єкти та морфізми деякої «абстрактної» категорії С в об'єкти та морфізми деякої «конкретнішої» категорії D.      Приклад. Розглянемо абстрактну групу G. Це те саме, що й категорія, яка складається з одного об'єкта, всі морфізми якої оборотні. В нашому випадку об'єкт нас не цікавить, тому його можна просто позначити ·, але морфізми – це елементи G, їх композиція здійснюється за допомогою операції множення в групі.      Тоді подання групи G на скінченний гільбертів простір – це те ж саме, що і функтор. Таким же чином, дія групи G на множину – це те саме, що й функтор. В обох випадках абстрактна група стає більш конкретною. Інший приклад функтора:      Для будь-якої множини A можна визначити наступний функтор: (- xA): Set -> Set – він відобразить будь-яку множину X в декартів добуток X × A. (Тут Set – категорія всіх множин.)  Визначення 4. Нехай F і G – функтори з категорії C в D. Тоді природне перетворення зіставляє кожному об'єкту X категорії C морфізм ηX F(X) -> G(X) в категорії D, що називається компонентом η в X, так що для будь-якого морфізму f: X -> Y зображена нижче діаграма комутативна. Визначення 5. Природним ізоморфізмом між функторами називається таке природне перетворення, що ηX є ізоморфізмом для кожного об’єкта X∈C.      Приклад. Розглянемо категорію H – групу, тобто категорію з одним об’єктом, наприклад ·. Тоді функтори F та G будуть представниками групи H в гільбертових просторах F(·) та G(·). Природним перетворенням в цьому випадку є переплітаючий оператор з одного подання в інше – лінійний оператор, що задовольняє умову AF(h) = G(h)A для всіх елементів групи H. Приклади природних перетворень: 1. Нехай є дві множини A та B і функція f: A -> B. Ця функція визначає природне перетворення між функторами (- xA), (- xB): Set -> Set. (- xf): (- xA) -> (- xB) за такою формулою: (x, a) -> (x, f(a)). 2. Для кожного A в Set існує природне перетворення 1 -> PA. Функтор PA: Set -> Set відображає довільну множину X в XA – множину функцій з A в X. Для будь-якого X в Set функція з X в XA буде відображати кожен елемент x з X в константну функцію з A в X.  Монада      Монада в категорії C – це функтор T: C -> C з двома природними перетвореннями: η: 1 -> T та µ: T ° T -> T. (Ендофунктор – функтор з категорії в саму себе.) Тоді нехай T(η): T -> T ° T – перетворення, результатом якого є застосування T до η та T(µ): (T ° T) ° T -> T ° T.   Тоді маємо такі аксіоми для монад: • T(η) ° µ – це тотожність T -> T:• T(µ) ° µ рівносильно µ ° µ:Приклади монад: 1. Для будь-якої категорії C може бути визначена тотожна монада, що складається з тотожного функтора та тотожного морфізму.2. Розглянемо групу G. Визначимо монаду MG в Set.Функтор монади: MG : X -> X × G. u(X): X -> X × G відображає елемент x в пару (x, e), де e – одиниця групи.MG (MG (X)) = (idX, mG), де mG – множення груп.Моноїдальні категорії Визначення 6. Декартовим добутком C × C′ категорій C та C′ називається категорія, в якій: • об'єктами є пари: X∈C та X′∈C′, тобто (X, X');• морфізм (X1, X'1) -> (X2, X'2) є парою (f1, f2), де f1: X1 -> X'1 і f2: X2 -> X'2. Визначення 7. Моноїдальна категорія складається з: • біфунктора, що називається тензорний добуток або моноїдальний добуток,• об'єкту I, що називається одиницею або тотожним об'єктом,• трьох природних ізоморфізмів, що виражають той факт, що операція тензорного добутку– асоціативна: існує природний ізоморфізм (так званий асоціатор) αA,B,C: (A ⊗ B) ⊗ C -> A ⊗ (B ⊗ C), – I є одиницею: існують два природні ізоморфізми λ та ρ: λA: I ⊗ A -> A, ρA: A ⊗ I -> A. На ці природні ізоморфізми накладено додаткові умови:  • для всіх об'єктів A, B, C, D наступна п'ятикутна діаграма коммутативна:   • для всіх A та B наступна трикутна діаграма коммутативна: Приклад моноїдальної категорії: категорію Set можна перетворити на моноїдальну, якщо взяти за операцію X⊗Y об'єднання множин.   Декартів добуток об'єктів Визначення 7. Для заданих об'єктів X і X' в деякій категорії вважається, що об'єкт X × X', асоційований з морфізмами p × p' (p: X × X' -> X, а p′: X × X' -> X' – проекції X × X' в множини X, X'), є декартовим добутком (або просто добутком) об'єктів X та X′ якщо для кожного об'єкта Q і морфізмів f, f'  має місце єдиний морфізм g, разом з яким наступна діаграма є комутативною:    Замкнена категорія      Симетрична моноїдальна категорія називається замкненою, якщо для будь-якого її об'єкту B функтор, що задається тензорним множенням на B справа A -> A⊗ B, має правий спряжений. (Функтори F і G спряжені, якщо вони задовольняють співвідношення Hom (F(X), Y) = Hom (X, G(Y)). При цьому F називається лівим спряженим функтором, а G – правим.)      Категорія C називається декартово замкненою, якщо вона задовольняє три умови: • C містить термінальний об'єкт (об’єкт T – термінальний, якщо для будь-якого об'єкта X в C існує єдиний морфізм X -> T); • будь-які два об'єкти X, Y в C мають добуток X × Y; • будь-які два об'єкти Y, Z в C мають експоненціал ZY.      Експоненціал – категорний аналог множини функцій в теорії множин. Більш точно експоненціал ZY можна визначити як універсальний морфізм з функтора (- xY) в Z. (Функтор (- xY) з C в C відображає об'єкт X в X×Y та морфізми φ у φ×idY).       Інакше кажучи, експоненціал ZY об'єктів Z та Y – це об'єкт, який разом з морфізмом eval: ZY×Y -> Z (відображення оцінки) такий, що для будь-якого об'єкта X і морфізму g: X×Y -> Z існує єдиний морфізм λg: X -> ZY, для якого наступна діаграма комутативна:      В категорії множин ZY експоненціал – це множина всіх функцій з Y в Z. Для довільного відображення g: (X×Y) -> Z, відображення λg: X -> ZY має вигляд λg(x)(y) = g(x, y).
Рекомендована література 1. Harold Abelson and Gerald Jay Sussman with Julie Sussman. Structure and Interpretation of Computer Programs, 2nd ed, MIT Press, 1996, 657 p. https://web.mit.edu/6.001/6.037/sicp.pdf2. Э. Хювёнен, Й. Сеппянен. Мир Лиспа. В 2-х т. Пер.с финск. – М: Мир, 1990.3. Peter Seibel. Practical Common Lisp, Apress, 2005, 501 p. https://gigamonkeys.com/book/4. Підручник по Haskell: https://anton-k.github.io/ru-haskell-book/book/home.html5. Miran Lipovaca. Learn You a Haskell for Great Good!: A Beginner's Guide, No Starch Press, 2011, 400 p.Переклад українською: https://haskell.trygub.com/6. Bryan O'Sullivan, Don Stewart, and John Goerzen. Real World Haskell, O'Reilly Media, 2009, 670 p. http://book.realworldhaskell.org/7. Will Kurt. Get Programming with Haskell, Manning Publications, 2018, 616 p.8. C. Hankin. An Introduction to Lambda Calculi for Computer Scientists, Kings College, 2004, 164 p.9. Х. Барендрегт. Ламбда-исчисление. Его синтаксис и семантика. –М.: Мир, 1985. – 606 с.10. Математическая логика в программировании: сборник статей (ред. Захарьящев М.В., Янова Ю.И.). – М.: Мир, 1991. – 408 с.64  64  64  